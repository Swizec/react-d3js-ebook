# Visualizing data with React and d3.js

Welcome to the main part of the book. I’m going to walk you through an example of building a simple visualization using React and d3.js.

We are going to build a subset of the code I used to [visualize the salary distribution of H1B workers](http://swizec.github.io/h1b-software-salaries/#2014-ca-engineer) in the United States software industry.

![H1B salary distribution for engineers in California](images/engineers-california.png)

If you skipped the [section on setting up your environment](#the-environment), make sure you’ve got the following dependencies:

* d3.js
* React
* Bootstrap (for styling)
* Lodash

And you should have some way of starting a static file server locally. I like `live-server`.

We’re going to put all our code in a `src/` directory, and serve the compiled version out of `build/`. A `data/` directory is going to hold our data.

Before we begin, you should download the dataset from my Github repository, [here](https://github.com/Swizec/h1b-software-salaries/blob/65fac70fb44b23b1a9fe2ec923d246d654fb42e1/data/h1bs.csv). Save it in `data/`.

## JSX

We’re going to use Facebook’s JavaScript syntax extension called JSX to write our code. You can use React without JSX, but I feel that JSX exposes React’s full power much better.

The gist of JSX is that we can use HTML just like it was part of  JavaScript. No Mustache or messy string concatenation necessary. Your functions can return straight up HTML.

For instance, the code that renders our whole application is going to look like this:

{crop-start-line=418,crop-end-line=422,linenos=off,lang=jsx}
<<[A basic Render](code/src/main.jsx)

Which compiles to:

{title="JSX compile result", linenos=off, lang=js}
    React.render(
        React.createElement(H1BGraph, {url: “data/h1bs.csv”}),
        document.querySelectorAll(‘.h1bgraph’)[0]
    );

As you can see, HTML code translates to `React.createElement` calls, with attributes translated into a property dictionary. The beauty of this approach is that you can use React components as if they were HTML tags and that HTML attributes can be anything.

You’ll see later that anything from a simple value to a function or an object works equally well.

The approach is obviously than `+`-ing strings, but I haven’t decided whether it’s better than Mustache yet. Rich attributes are certainly powerful, but something feels fishy about essentially having multiple languages in a single file.

It’s definitely better than Angular’s put everything into HTML files approach though! Much better.

If you skipped the previous section and don’t have React compilation set up, I suggest you go do that now. You can also use `JSXTransform.js`, which performs the translation in browser. But the official documentation says you should avoid the client-side transform because of performance issues.

## The basic approach

Because SVG is just another XML-like format that fits into the DOM, we can assemble it with React. To draw a 100px by 200px rectangle inside a grouping element moved to (50, 20) we can do something like this:

{lang=jsx}
    render: function () {
        return (
            <g transform=“translate(50, 20)”>
                <rect width=“100” height=“200” />
            </g>
        );
    }

If the parent component makes sure to render this inside an `<svg>` element, the user will see a rectangle on their screen. At first glance this might look cumbersome compared to traditional d3.js. But look closely:

{lang=js}
    d3.select(“svg”)
      .append(“g”)
      .attr(“transform”, “translate(50, 20)”)
      .append(“rect”)
      .attr(“width”, 100)
      .attr(“height”, 200);

The d3 approach might look cleaner because it’s pure JavaScript and outputs SVG as if by magic. But it’s a lot more typing and function calls for the same result.

Well, after counting, the pure d3 example uses 10 less characters than the React example. Oops.

Anyway, my point is that manipulating the DOM is not d3’s strong suit. Especially once you get into the range of a few thousand elements and things become very slow unless you’re careful to only render what’s changing.

But with React, you get that behaviour for free. Its primary purpose in life is observing data changes and only updating those components that have actually changed.

So our app is going to follow a simple approach:

* React owns the DOM
* d3 calculates properties

This way we leverage both React and d3 just for what they’re best at.

{#the-architecture}
## The architecture

To make our lives easier we are going to use a flow-down architecture. I think Facebook has come up with a buzzword for this approach, but whatever.

The idea is this:

* The Main Component is the repository of truth
* Child components react to user events
* They announce changes up the chain of parents via callbacks
* The Main Component updates its truth
* The real changes flow back down the chain to update UI

This might look like a roundabout way of doing things, but I promise it’s awesome. Definitely easier than worrying about having parts of your UI out of date with the rest of the app. 

Having most of your components rely on just the properties they are given, is like having your functions rely on just the arguments they are given. This makes them easier to reason about, and you always know what you’re going to get.

Basically, rendering the same component with the same properties, will *always* give you the same output.

Functional programming for HTML. Sweet!

## The HTML skeleton

We’re building the whole interface with React, but we still need some HTML. It will take care of including files and giving us a container for React stuff.

Make an index.html file that looks like this:

{linenos=off,lang=html}
<<[HTML skeleton](code_samples/index.html)

These 20 lines do everything we need. The `<head>` sets some meta properties recommended by Bootstrap and includes our stylesheet. The `<body>` sets up a container and includes the JavaScript code.

We didn’t really need a `<div>` inside a `<div>` like that, but I like to avoid taking over the whole `.container` with React. Gives you more flexibility to add dumb static content that really doesn’t need React.

## The Main Component

As [mentioned before](#the-architecture) we are going to build everything off a central repository of truth - The Main Component. We’re going to call it `H1BGraph` because it draws a graph of H1B data.

Very imaginative, I know.

This code lives in `src/main.jsx` and starts by requiring React, Lodash, and d3:

{crop-start-line=5,crop-end-line=8,linenos=off,lang=jsx}
<<[Require the libraries](code_samples/main.jsx)

We’re going to add more imports later.

We also need a basic React component called `H1BGraph`. It should look like this:

{crop-start-line=10,crop-end-line=23,linenos=off,lang=jsx}
<<[Blank component](code_samples/main.jsx)

This creates a Bootstrap row with an `<svg>` element.

Add this at the bottom to make sure our component actually renders:

{crop-start-line=25,crop-end-line=29,linenos=off,lang=jsx}
<<[Render our component](code_samples/main.jsx)

If all is well, your browser’s document inspector should show a blank SVG wrapped in some divs.

### Loading data

Great, we’ve got something rendering. But we need to load some data before we can draw a picture. If you still haven’t downloaded the file into `data/h1bs.csv`, do it now. You can find it on Github, [here](https://github.com/Swizec/h1b-software-salaries).

We’re going to use d3’s built-in data loading magic and hook it into React’s component lifecycle. 

We start by adding three short methods to `H1BGraph`:

{crop-start-line=34,crop-end-line=49,linenos=off,lang=jsx}
<<[Base methods to load data](code_samples/main.jsx)

React calls `componentWillMount` right before inserting the component into the document. It’s a great opportunity to make any last minute preparations before rendering. In our case, it’s a good spot to start loading data.

You should avoid loading data that’s never rendered.

`getInitialState` is the React way to set up a default state. An empty `rawData` array in our case.

And we’re going to put d3’s data loading magic in `loadRawData`. 

We add a call to `d3.csv` because our data is in CSV format. D3 is smart enough to change every row into an object using values from the title row (first row) as keys.

{crop-start-line=74,crop-end-line=86,linenos=off,lang=jsx}
<<[Load data with d3.csv](code_samples/main.jsx)

This will asynchronously load a CSV file, parse it, and return the result in the `rows` argument to the callback. We then use `this.setState()` to save the data in our component.

Using `setState()` triggers a re-render and should generally be avoided because relying on state can cause inconsistencies in your UI. It’s very appropriate to store 12MB of raw data as state, though.

But the data we’ve got now has keys with spaces like `submit date` and `job title`. And everything is a string. Not very nice to work with.

We can add some cleanup in one fell swoop:

{crop-start-line=113,crop-end-line=144,linenos=off,lang=jsx}
<<[Data cleanup](code_samples/main.jsx)

Using `.row()`, we’ve given a callback to `d3.csv` that tells it what to do with every row it reads. Each row is fed into the function as a raw object, and whatever the function returns is added to the final result.

In our case we cleaned up the keys, parsed dates into `Date()` objects and made sure numbers are numbers. If a row didn’t have a `base_salary`, we filtered it out by returning null.

It’s also a good idea to give users some idea what’s going on. Especially when they’re looking at a blank page while the data loads. 

The easiest way to do that is by rendering some explainer text when there’s no data.

{crop-start-line=205,crop-end-line=223,linenos=off,lang=jsx}
<<[Loading state](code_samples/main.jsx)

The beauty of this approach is that our `render` method just needs to return different elements based on whether we’ve got some data or not. Notice we access the data as `this.state.rawData` and rely on the re-render when the state updates.

Marvelous.

