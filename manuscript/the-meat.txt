# Visualizing data with React and d3.js

Welcome to the main part of the book. I’m going to walk you through an example of building a simple visualization using React and d3.js.

We are going to build a subset of the code I used to [visualize the salary distribution of H1B workers](http://swizec.github.io/h1b-software-salaries/#2014-ca-engineer) in the United States software industry.

![H1B salary distribution for engineers in California](images/engineers-california.png)

If you skipped the [section on setting up your environment](#the-environment), make sure you’ve got the following dependencies:

* d3.js
* React
* Bootstrap (for styling)
* Lodash

And you should have some way of starting a static file server locally. I like `live-server`.

We’re going to put all our code in a `src/` directory, and serve the compiled version out of `build/`. A `data/` directory is going to hold our data.

Before we begin, you should download the dataset from my Github repository, [here](https://github.com/Swizec/h1b-software-salaries/blob/65fac70fb44b23b1a9fe2ec923d246d654fb42e1/data/h1bs.csv). Save it in `data/`.

## JSX

We’re going to use Facebook’s JavaScript syntax extension called JSX to write our code. You can use React without JSX, but I feel that JSX exposes React’s full power much better.

The gist of JSX is that we can use HTML just like it was part of  JavaScript. No Mustache or messy string concatenation necessary. Your functions can return straight up HTML.

For instance, the code that renders our whole application is going to look like this:

{crop-start-line=418,crop-end-line=422,linenos=off,lang=jsx}
<<[A basic Render](code/src/main.jsx)

Which compiles to:

{title="JSX compile result", linenos=off, lang=js}
    React.render(
        React.createElement(H1BGraph, {url: “data/h1bs.csv”}),
        document.querySelectorAll(‘.h1bgraph’)[0]
    );

As you can see, HTML code translates to `React.createElement` calls, with attributes translated into a property dictionary. The beauty of this approach is that you can use React components as if they were HTML tags and that HTML attributes can be anything.

You’ll see later that anything from a simple value to a function or an object works equally well.

The approach is obviously than `+`-ing strings, but I haven’t decided whether it’s better than Mustache yet. Rich attributes are certainly powerful, but something feels fishy about essentially having multiple languages in a single file.

It’s definitely better than Angular’s put everything into HTML files approach though! Much better.

If you skipped the previous section and don’t have React compilation set up, I suggest you go do that now. You can also use `JSXTransform.js`, which performs the translation in browser. But the official documentation says you should avoid the client-side transform because of performance issues.

## The basic approach

Because SVG is just another XML-like format that fits into the DOM, we can assemble it with React. To draw a 100px by 200px rectangle inside a grouping element moved to (50, 20) we can do something like this:

{linenos=off,lang=jsx}
    render: function () {
        return (
            <g transform=“translate(50, 20)”>
                <rect width=“100” height=“200” />
            </g>
        );
    }

If the parent component makes sure to render this inside an `<svg>` element, the user will see a rectangle on their screen. At first glance this might look cumbersome compared to traditional d3.js. But look closely:

{linenos=off,lang=js}
    d3.select(“svg”)
      .append(“g”)
      .attr(“transform”, “translate(50, 20)”)
      .append(“rect”)
      .attr(“width”, 100)
      .attr(“height”, 200);

The d3 approach might look cleaner because it’s pure JavaScript and outputs SVG as if by magic. But it’s a lot more typing and function calls for the same result.

Well, after counting, the pure d3 example uses 10 less characters than the React example. Oops.

Anyway, my point is that manipulating the DOM is not d3’s strong suit. Especially once you get into the range of a few thousand elements and things become very slow unless you’re careful to only render what’s changing.

But with React, you get that behaviour for free. Its primary purpose in life is observing data changes and only updating those components that have actually changed.

So our app is going to follow a simple approach:

* React owns the DOM
* d3 calculates properties

This way we leverage both React and d3 just for what they’re best at.

{#the-architecture}
## The architecture

To make our lives easier we are going to use a flow-down architecture. I think Facebook has come up with a buzzword for this approach, but whatever.

The idea is this:

* The Main Component is the repository of truth
* Child components react to user events
* They announce changes up the chain of parents via callbacks
* The Main Component updates its truth
* The real changes flow back down the chain to update UI

This might look like a roundabout way of doing things, but I promise it’s awesome. Definitely easier than worrying about having parts of your UI out of date with the rest of the app. 

Having most of your components rely on just the properties they are given, is like having your functions rely on just the arguments they are given. This makes them easier to reason about, and you always know what you’re going to get.

Basically, rendering the same component with the same properties, will *always* give you the same output.

Functional programming for HTML. Sweet!

## The HTML skeleton

We’re building the whole interface with React, but we still need some HTML. It will take care of including files and giving us a container for React stuff.

Make an index.html file that looks like this:

{linenos=off,lang=html}
<<[HTML skeleton](code_samples/index.html)

These 20 lines do everything we need. The `<head>` sets some meta properties recommended by Bootstrap and includes our stylesheet. The `<body>` sets up a container and includes the JavaScript code.

We didn’t really need a `<div>` inside a `<div>` like that, but I like to avoid taking over the whole `.container` with React. Gives you more flexibility to add dumb static content that really doesn’t need React.

## The Main Component

As [mentioned before](#the-architecture) we are going to build everything off a central repository of truth - The Main Component. We’re going to call it `H1BGraph` because it draws a graph of H1B data.

Very imaginative, I know.

This code lives in `src/main.jsx` and starts by requiring React, Lodash, and d3:

{crop-start-line=5,crop-end-line=8,linenos=off,lang=jsx}
<<[Require the libraries](code_samples/main.jsx)

We’re going to add more imports later.

We also need a basic React component called `H1BGraph`. It should look like this:

{crop-start-line=10,crop-end-line=23,linenos=off,lang=jsx}
<<[Blank component](code_samples/main.jsx)

This creates a Bootstrap row with an `<svg>` element.

Add this at the bottom to make sure our component actually renders:

{crop-start-line=25,crop-end-line=29,linenos=off,lang=jsx}
<<[Render our component](code_samples/main.jsx)

If all is well, your browser’s document inspector should show a blank SVG wrapped in some divs.

## Loading data

Great, we’ve got something rendering. But we need to load some data before we can draw a picture. If you still haven’t downloaded the file into `data/h1bs.csv`, do it now. You can find it on Github, [here](https://github.com/Swizec/h1b-software-salaries).

We’re going to use d3’s built-in data loading magic and hook it into React’s component lifecycle. 

We start by adding three short methods to `H1BGraph`:

{crop-start-line=34,crop-end-line=49,linenos=off,lang=jsx}
<<[Base methods to load data](code_samples/main.jsx)

React calls `componentWillMount` right before inserting the component into the document. It’s a great opportunity to make any last minute preparations before rendering. In our case, it’s a good spot to start loading data.

You should avoid loading data that’s never rendered.

`getInitialState` is the React way to set up a default state. An empty `rawData` array in our case.

And we’re going to put d3’s data loading magic in `loadRawData`. 

We add a call to `d3.csv` because our data is in CSV format. D3 is smart enough to change every row into an object using values from the title row (first row) as keys.

{crop-start-line=74,crop-end-line=86,linenos=off,lang=jsx}
<<[Load data with d3.csv](code_samples/main.jsx)

This will asynchronously load a CSV file, parse it, and return the result in the `rows` argument to the callback. We then use `this.setState()` to save the data in our component.

Using `setState()` triggers a re-render and should generally be avoided because relying on state can cause inconsistencies in your UI. It’s very appropriate to store 12MB of raw data as state, though.

But the data we’ve got now has keys with spaces like `submit date` and `job title`. And everything is a string. Not very nice to work with.

We can add some cleanup in one fell swoop:

{crop-start-line=113,crop-end-line=144,linenos=off,lang=jsx}
<<[Data cleanup](code_samples/main.jsx)

Using `.row()`, we’ve given a callback to `d3.csv` that tells it what to do with every row it reads. Each row is fed into the function as a raw object, and whatever the function returns is added to the final result.

In our case we cleaned up the keys, parsed dates into `Date()` objects and made sure numbers are numbers. If a row didn’t have a `base_salary`, we filtered it out by returning null.

It’s also a good idea to give users some idea what’s going on. Especially when they’re looking at a blank page while the data loads. 

The easiest way to do that is by rendering some explainer text when there’s no data.

{crop-start-line=205,crop-end-line=223,linenos=off,lang=jsx}
<<[Loading indicator](code_samples/main.jsx)

The beauty of this approach is that our `render` method just returns different elements based on whether we’ve got some data or not. Notice we access the data as `this.state.rawData` and rely on the re-render when the state updates.

If you’ve kept live-server and Grunt running in the background, you should see your browser flash the loading text before becoming blank.

Marvelous.

## Drawing the loaded data

Now that we’ve got our data loading, it’s time to start drawing.  We’ll start with a basic histogram, then add an axis, and an indicator for the mean value.

Create a new file in `src/` called `drawers.jsx`. We’ll put all our drawing logic here.

### Using d3 for calculations

We start with a blank component called `Histogram`.

{crop-start-line=5,crop-end-line=21,linenos=off,lang=jsx}
<<[Empty histogram](code_samples/drawers.jsx)

Once more we required external libraries on top and started our component with a simple `render` function. On the bottom we added it to the exports. This will allow other parts of the codebase to use it as `require(‘drawers.jsx’).Histogram`.

In the `render` method we created a grouping, `<g>` element that will hold our histogram together and used the `transform` property to move it into place. The reason we have to do it with some ugly string concatenation is that we can’t mix string and variable attribute values.

But we do want to get `topMargin` via properties given to our component. We access those with `this.props` and they make our components more flexible.

Anyway, we’re going to use d3’s built-in histogram layout to make our histogram. It’s smart enough to do everything on its own, we just give it some data, and tell it how many bars we want.

We add three methods to our `Histogram` component to manage d3:

{crop-start-line=26,crop-end-line=45,linenos=off,lang=jsx}
<<[D3 management functions](code_samples/drawers.jsx)

This is the cleanest approach I’ve found to make d3 and React work together. We’ll use it for all our d3-enabled components.
	
The problem is that the way d3 achieves its declarative nature is through objects. When you call a d3 function it will almost always have some internal state.

Which is great when you want to change how it behaves by daisy chaining getters and setters on top of it. But it causes problem with React because it means we have to make sure that internal state is always up to date.

We do this by relying on `componentWillMount` to set the defaults, and then `componentWillRecieveProps` to update them whenever the component receives new properties.

Each time we call `this.update_d3` to do the heavy lifting.

{crop-start-line=71,crop-end-line=90,linenos=off,lang=jsx}
<<[update_d3 function body](code_samples/drawers.jsx)

If you’re used to d3, this code should look familiar. We updated the number of bins in the histogram with `.bins()` and gave it a new value accessor with `.value()`. This tells it how to get the interesting data point from our data objects.

We’re actually just using the function given to us by our parent component. This makes our `Histogram` component more reusable. The less we assume about what we’re doing, the better.

Then we called `this.histogram()` to group our data into bins and saved it to the component’s state with `this.setState()`.

Finally we updated our scales. You can think of them as simple mathematical functions that map a domain to a range. Domain tells them the extent of our data, range tells them the extent of our desired drawing area.

### Outputting the result

Now that we’ve got our histogram in memory, it’s time to output it. This will be standard React stuff, but SVG.

{crop-start-line=137,crop-end-line=166,linenos=off,lang=jsx}
<<[Draw the histogram bars](code_samples/drawers.jsx)

We added another grouping element to our `render` function. This one just holds all the bars. I’ll show you why we need two grouping elements later.

But notice how we can just `.map()` through our histogram data in `this.state.bars`? That’s the magic of React - JavaScript and XML living together as one.

We could have put the entire `makeBar` method in here, but I think the code looks cleaner when it’s separate. `makeBar` takes data about a single bar, constructs the properties object and returns a `HistogramBar` component.

We could have returned the whole lump of SVG code right here, but using a subcomponent is better aligned with React principles. 

Also notice how we can pass the entire `props` object with `{...props}`. That’s an ES6 trick for passing around complex attributes. React translates it into something like `percent={percent} x={this.props.axisMargin} y={this.yScale(bar.x)} …`.

Let’s add the `HistogramBar` component.

{crop-start-line=172,crop-end-line=192,linenos=off,lang=jsx}
<<[HistogramBar component](code_samples/drawers.jsx)

As you can see, nothing special is happening here. We take some properties and return a grouping element containing a rectangle and a text label.

We’ve made the rectangle a bit smaller than `this.props.height` so the bars get some spacing, and we positioned the `text` element at the end of the bar. This will make the histogram easier to read because every bar will have its percentage rendered at its top.

But some bars are going to be very small. It’s a good idea to avoid rendering the label in those cases.

{crop-start-line=196,crop-end-line=213,linenos=off,lang=jsx}
<<[Adjust label for small bars](code_samples/drawers.jsx)

Simple stuff. We add some decimal points if we’re showing small numbers, and we completely remove the label when the bar is very small.

### Adding Histogram to the main component

Marvelous, we know how to draw a histogram!

But the page is still blank. We now have to go back to `main.jsx` and tell `H1BGraph` to render our `Histogram` component.

First we have to add `drawers.jsx` to our requires.

{crop-start-line=230,crop-end-line=234,linenos=off,lang=jsx}
<<[Require drawers.jsx](code_samples/main.jsx)

Then we can add the histogram component to our `render` method.

{crop-start-line=274,crop-end-line=305,linenos=off,lang=jsx}
<<[Render the histogram component](code_samples/main.jsx)

And that’s it. You can render as many histograms as you want by just adding `<drawers.Histogram />` to your output and feeding it some info.

We just have to add some styling to `src/style.less` to make the Histogram prettier:

{crop-start-line=5,crop-end-line=19,linenos=off,lang=less}
<<[style.less](code_samples/style.less)

You should be able to see something like this now:

![Basic Histogram](images/base_histogram.png)

## Adding an axis

Axes are one of my favourite feats of d3 magic. You just call a function, set some parameters and bam, you’ve got an axis.

The created axis automatically adapts to your data, draws just the ticks it actually needs and even labels them. They’re even smart enough to work with different types of scales. You don’t have to do anything special to turn a linear axis into a logarithmic axis.

But these are complex objects and recreating them in React would be silly. We’re going to use a dirty trick and give d3 control of the DOM just this once.

Let’s start with a blank component that’s got function stubs for d3 integration. Put it in `src/drawers.jsx`.

{crop-start-line=232,crop-end-line=252,linenos=off,lang=jsx}
<<[Axis component with function stubs](code_samples/drawers.jsx)

Even though we’re going to let d3 handle DOM changes in this case, we still have to return *something* in `render`. A grouping element that moves the resulting axis into position is the perfect candidate.

Now let’s set some axis defaults in `componentWillMount`:

{crop-start-line=257,crop-end-line=270,linenos=off,lang=jsx}
<<[Axis default properties](code_samples/drawers.jsx)

We created a scale and an axis. The axis will use our linear scale, will be oriented to the left, and is going to prepend a dollar sign to the scale’s default tick formatter.

Yes, scales have tick formatters. It’s awesome.

In `update_d3` we have to make sure thing stay up to date:

{crop-start-line=309,crop-end-line=324,linenos=off,lang=jsx}
<<[Update axis state](code_samples/drawers.jsx)

Just like we did in the previous section, we had to tell `yScale` the extent of our data and drawing area. But we didn’t have to tell any of this to the axis. It already knows because we updated the scale.

But we did have to get around a lot of the axis’s smartness. We gave it the exact number of ticks we want and the exact values they should show. This is because we wanted every bar in the histogram to have a corresponding label on the axis.

And finally, the dirty trick.

{crop-start-line=369,crop-end-line=381,linenos=off,lang=jsx}
<<[The dirty trick](code_samples/drawers.jsx)

I’m sure this goes against everything React designers fought for, but it works great. We hook into the `componentDidUpdate` and `componentDidMount` callbacks with a `renderAxis` method. Then we use `this.getDOMNode()` to get a reference to the rendered element, feed it into `d3.select()` and `.call()` the axis on it.

What we’re doing is basically throwing away the whole element and creating it from scratch on every render. Rather inefficient, but it’s okay if used sparingly.

But we do have to handle two more things before our Axis renders on page.

First, add some styling to `src/style.less`:

{crop-start-line=23,crop-end-line=46,linenos=off,lang=less}
<<[Styling the axis](code_samples/style.less)

And we have to add the axis to our Histogram component’s `render` method.

{crop-start-line=446,crop-end-line=459,linenos=off,lang=jsx}
<<[Add Axis to Histogram.render](code_samples/drawers.jsx)

That’s it. Your histogram should now look something like this:

![Histogram with axis](images/axis_histogram.png)

## Reacting to data changes

We’ve got a histogram with an axis. And reusable building blocks to make as many as we want. That’s awesome!

But our histogram looks kind of weird. Most of the data is scrunched up into the first three bars and a lone outlier stretches our data range far too much.

Sure, we could take care of this by removing the outlier. But let’s leave defining statistical anomalies to statisticians. We’re here to draw pictures.

The next best thing is giving users the ability to filter data and take a closer look. Solves our problem of finding outliers, gives users more freedom. And maybe, just maybe, they’re going to spend more time on our site. 

Win-win-win.

We’re going to make controls that let users filter data by year. In the full example I added filtering by state and job title as well, but they follow the same principles and including them here would take too long.

### Creating user controls

Our controls are going to be organised into three components:

* Controls, which holds the controls together
* ControlRow, which is a row of buttons
* Toggle, which is a toggleable button

Let’s start a new file called `src/controls.jsx` with a `Controls` component stub:

{crop-start-line=5,crop-end-line=19,linenos=off,lang=jsx}
<<[Controls component stub](code_samples/controls.jsx)

We’re going to need React and Lodash in this file, and Controls is the only component we’ll expose to the outside.

And let’s quickly add this to the main `H1BGraph` component. It’s just three lines of HTML inside `render`:

{crop-start-line=370,crop-end-line=385,linenos=off,lang=jsx}

We had to wrap everything in another `<div>` because React throws a hissy fit if we try to return multiple elements side-by-side, and we used props to give the `Controls` component some data and the update callback.

And don’t forget to add `Controls = require(‘./controls.jsx’)` somewhere near the top of the file.

Great, you’ve got some empty components showing up on the screen. Let’s add some rows of buttons to the `Controls.render` method:

{crop-start-line=24,crop-end-line=47,linenos=off,lang=jsx}
<<[Render a ControlRow](code_samples/controls.jsx)

This will break in your browser because we don’t have a `ControlRow` component yet. The idea is to have component that takes data, a function that generates the button labels and an `updateDataFilter` callback.

We’ll define the callback later. Let’s make the `ControlRow` component first.

{crop-start-line=51,crop-end-line=72,linenos=off,lang=jsx}
<<[ControlRow component](code_samples/controls.jsx)

Nothing special going on here. We’ve got a `render` method that returns a Bootstrap row and fills with with a bunch of `Toggle` components. It does this by looping over the result of `this.props.getTogglevalues`, which is teh function we defined in `Controls.render`.

Normally `onClick` is a click event handler. React gives us this sort of magic prop for every valid user event. It’s the same as jQuery’s `$(‘foo’).on(‘click’)`.

But they only work on HTML elements, not React components. So this one is just a function callback that we’ll use.

We had to define the `key` property to help React identify specific elements. I assume it uses these to identify which elements to re-render, if they’re created in a loop.

There’s also the weird `on` property that comes out of `this.state.togglesOn`. It tells our toggles whether to render as turned on or off and the reason we track this state in `ControlRow` is to make sure only one can be turned on at a time.

Let’s add this state handling.

{crop-start-line=77,crop-end-line=100,linenos=off,lang=jsx}
<<[Exclusive toggling](code_samples/controls.jsx)

The `makePick` function is called when the user clicks on a `Toggle` element. It goes through the `togglesOn` dictionary and  sets them to `false` if they aren’t the one currently picked. That one is set to `true`.

Then it saves the dictionary with `this.setState`, which triggers a re-render and updates all the buttons.

And we used the trusty `getInitialState` to create the `togglesOn` dictionary with everything set to `false`.

Now we need the `Toggle` component.

{crop-start-line=124,crop-end-line=146,linenos=off,lang=jsx}
<<[Toggle component](code_samples/controls.jsx)

Toggle renders a button. If `this.state.on` is true, the button is highlighted. We set it to off by default, and update it when `componentWillReceiveProps` triggers. That happens when the component’s properties change from above.

Now your page shows three buttons under the histogram:

![Histogram with buttons](images/buttons_histogram.png)

But clicking on a button will throw an error.

### Propagating events up the hierarchy

To make the buttons work, we have to implement our click event handler - `this.handleClick`. Then we have to call every callback up the chain until we get to the histogram component, which is our holder of truth.

It’s a roundabout way of doing things, but it makes our architecture simpler. Data always flows down from the bottom and data changing events flow up.

Let’s start by adding a click handler to the `Toggle` component:

{crop-start-line=151,crop-end-line=163,linenos=off,lang=jsx}
<<[Toggle click handler](code_samples/controls.jsx)

A simple function as you can see. It toggles the `on` state and calls the `this.props.onClick` callback.

The reason we’re using state to highlight the button is that making this change eagerly instead of waiting for propagation looks better to the user. It’s a tiny bit more instant and it makes our app look less laggy.

But we still override this state in `componentWillReceiveProps` if the parent component wants us to.

If you click around now, the buttons are going to toggle on and off. And `ControlRow` will keep making sure you can only choose one at a time.

![2013 toggled on](images/togglable_buttons.png)

To make these changes propagate further than `ControlRow`, we have to call its callback in the `makePick` method:

{crop-start-line=185,crop-end-line=200,linenos=off,lang=jsx}
<<[Callback in ControlRow.makePick](code_samples/controls.jsx)

Nothing fancy, just a call to `this.props.updateDataFilter` with information on what was picked and whether we want to reset the filter or not. The reset is used when the user clicks on a button that’s turned on.

Now comes the fun part. We get to construct the data filter in our `Controls` component, then tell the main `H1BGraph` component about it.

We gave `this.updateYearFilter` as the update callback to `ControlRow`. It’s a simple function that just creates a filter function based on the chosen year and saves it with `setState()`. Like this:

{crop-start-line=255,crop-end-line=274,linenos=off,lang=jsx}
<<[Controls.updateYearFilter function](code_samples/controls.jsx)

And we added the `getInitialState` function to make sure the filter is set to an “accept everything” version at first.

Next step is to tell the parent component about our new filter.

{crop-start-line=348,crop-end-line=368,linenos=off,lang=jsx}
<<[Propagating filter up the chain](code_samples/controls.jsx)

React calls `componentDidUpdate` when we change the state, which gives us a great opportunity to call our filter callback - `this.props.updateDataFilter`. We feed it a new filter function that combines all the potential filters in our state. In this case just `yearFilter`.

Now, you’d think we could do all of this straight in the `updateYearFilter` function, but we don’t have access to the new state yet. And because we might add more types of filters later, it’s easier to just rely on the filters already saved in state.

But we’ve just caused an infinite loop. When `componentDidUpdate` is called we call something on the parent component. This potentially changes our `props`, which again triggers `componentDidUpdate`.

We have to make sure the component updates *only* when properties have actually changed. The easiest way to do that is using `shouldComponentUpdate` like we did. If it returns false, component doesn’t update.

An apparently better option is using the [PureRenderMixin](http://facebook.github.io/react/docs/pure-render-mixin.html), which makes sure components only update when properties actually change. Could be worth a shot.

Anyway, it’s time to add the filtering functionality to `H1BGraph`.

{crop-start-line=427,crop-end-line=440,linenos=off,lang=jsx}
<<[Filter update callback in H1BGraph](code_samples/main.jsx)

Nothing fancy. We initially set the `dataFilter` to accept everything and update it when something calls `updateDataFilter` with a new one.

The last step is actually filtering the data in our `H1BGraph.render` method.

{crop-start-line=535,crop-end-line=555,linenos=off,lang=jsx}
<<[Filter data in H1BGraph.render](code_samples/main.jsx)

As you can see, we didn’t have to do much. We just gave the `Histogram` component data passed through a filter instead of raw.

You should now be able to see something like this:

![Histogram with only 2014 salaries](images/2014_histogram.png)

Hooray! Histogram with user filtering.

A lot of work went into that and we’ve got plenty of moving parts. But remember, all you have to do now to add more filters is to add another `<ControlRow />` to `Controls`, write a filter function for it, and make sure it’s included in `updateDataFilter`.

That’s it. A minute of typing to give users the ability to filter by almost anything.

## Adding a nice title

If you’ve followed along this far, you’ve got a nice histogram of H1B salaries in the software industry. It renders fully on the frontend, changes when the user picks a specific year, and you’ve got a couple of building blocks to make it better.

But all good visualizations need a title. Otherwise users don’t know what they’re looking at.

Let’s add one. And let’s make it change when the visualization changes.

Bloop.
