## Asynchronously loading data

Great, we’ve got a component rendering. Now we need to load some data before we can draw a picture. If you still don't have `public/data/h1bs.csv`, now is the time to get it. You can find it on Github [here](https://github.com/Swizec/h1b-software-salaries), or in the stub project included with the book.

We’re going to use d3.js’s built-in data-loading magic and hook it into React’s component lifecycle for a seamless integration. You could implement calls to a REST API in the same way.

We start by adding three methods to `H1BGraph` in `src/components/H1BGraph/index.jsx`:

{crop-start-line=54,crop-end-line=72,linenos=off,lang=jsx}
<<[Base methods to load data](code_samples/es6/H1BGraph/index.jsx)

With ES6 classes we no longer use `getInitialState` to set the initial state of our component. That job is taken over by the constructor, which is a function that gets called every time our class is instantiated into an object. We always have to call `super()` first to call the parent's constructor. In our case that's React's `Component`.

After calling `super()`, we can use `this.state` as a dictionary that hold's our component's current state. We'll want to avoid using component state as much as possible and rely instead on props fed into the component at render time. 

Next we have `componentWillMount`, which is a component lifecycle function that React calls just before mounting, also known as rendering, our component into the page. This is where you'd want to fit any last minute preparations before rendering.

It's also a great moment to start loading data. Especially when you have 12MB of data like we do. Wouldn't want to load that unless you know for sure, the component is getting rendered.

We’re going to put d3.js’s data loading magic in `loadRawData`. The reason we have a separate function and don't stick everything into `componentWillMount` is flexibility - we can call the function whenever we want without messing with React's built-in functions.

We use `d3.csv` to load our dataset because it's in CSV format. `d3.csv` understands CSV well enough to turn it into an array of dictionaries, using the first row as keys. If our data was JSON, we'd use `d3.json`, `d3.html` for HTML, etc. You can find the full list of data loaders in d3's documentation.

{crop-start-line=103,crop-end-line=115,linenos=off,lang=jsx}
<<[Load data with d3.csv](code_samples/es6/H1BGraph/index.jsx)

This asynchronously loads a CSV file, parses it, and returns the result in the `rows` argument to the callback. The callback is an ES6 fat arrow, which is syntax sugar for `function () { // .. }.bind(this)` - a function bound to current scope. We're going to use these a lot.

Inside the callback we check for errors, and if everything went well, use `this.setState()` to save the loaded data in our component's state. Calling `setState()` triggers a re-render and should generally be avoided because relying on state can lead to inconsistencies in your UI. It’s very appropriate to store 12MB of raw data as state, though.

We're now going to be able to access our data with `this.state.rawData`. Hooray!

### Data cleanup

Datasets are often messy or at least annoying to work with. After a naive load like that, our data uses keys with spaces in them and everything is a string. Not nice to work with at all.

We can add some cleanup in one fell swoop:

{crop-start-line=148,crop-end-line=172,linenos=off,lang=jsx}
<<[Data cleanup](code_samples/es6/H1BGraph/index.jsx)

Using `.row()`, we’ve given a callback to `d3.csv` that tells it how to change every row that it reads. Each row is fed into the function as a raw object, and whatever the function returns is added to the final result.

We're changing objects that look like this:

{title="Raw CSV rows",linenos=off,lang=js}
			{
			    "employer": "american legalnet inc",
			    "submit date": "7/10/2013",
			    "start date": "8/1/2013",
			    "case status": "certified",
			    "job title": "software",
			    "base salary": "80000",
			    "salary to": "",
			    "city": "encino",
			    "state": "ca"
			}

Into objects that look like this:

{title="Cleaned CSV rows",linenos=off,lang=js}
			{
			    "employer": "american legalnet inc",
			    "submit_date": "2013-07-09T22:00:00.000Z",
			    "start_date": "2013-07-31T22:00:00.000Z",
			    "case_status": "certified",
			    "job_title": "software",
			    "clean_job_title": "other",
			    "base_salary": 80000,
			    "salary_to": null,
			    "city": "encino",
			    "state": "ca"
			}

In our case we cleaned up the keys, parsed dates into `Date()` objects using d3's built-in date formatters, and made sure numbers are numbers. If a row didn’t have a `base_salary`, we filtered it out by returning `null`.

### Add visual feedback that loading is happening

Loading and parsing 81,000 data points takes some time. Let's tell users what they're waiting for by rendering some explainer text when there's no data.

{crop-start-line=244,crop-end-line=253,linenos=off,lang=jsx}
<<[Loading indicator](code_samples/es6/H1BGraph/index.jsx)

The beauty of our approach is that the `render` method returns different elements based on whether or not we’ve got some data. Notice that we access the data as `this.state.rawData` and rely on the re-render triggered by `this.setState` to get rid of the loading notice.

If you’ve kept `npm start` running in the background, your browser should flash the loading text before becoming blank.

![Loading message](images/loading_message.png)

Marvelous.

## Making your first dataviz component - a Histogram

Now that our data is loading, it’s time to start drawing.  We’ll start with a basic histogram, then add an axis, and then add an indicator for the mean value (also known as the "average").

A histogram component isn't unique to our project, so we're going to build it as a standalone component. Create a new directory `src/components/Histogram/`, with an empty `index.jsx` file.

We use `index.jsx` as a convenience to make our component easier to import so we won't put any logic in here. The whole file looks like this:

{linenos=off,lang=jsx}
<<[src/components/Histogram/index.jsx](code_samples/es6/Histogram/index.jsx)

It just imports and exports `Histogram`. Now the rest of our project can use `import Histogram from '../Histogram'` without understanding the internal file structure of our component. Users of your components should never have to know how you organized your component internally.

### A blank Histogram component

We start with a blank `Histogram` component in `src/components/Histogram/Histogram.jsx`, like this:

{crop-start-line=4,crop-end-line=19,linenos=off,lang=jsx}
<<[Empty histogram](code_samples/es6/Histogram/Histogram.jsx)

Just like in `H1BGraph`, we first required some external libraries - React and d3, created a class with a `render()` function, and added it to our exports. This lets other parts of the codebase use it by calling `import Histogram from './Histogram'`.

Right now the `render()` method contains only an empty grouping, `<g>`, element. These are much like divs in HTML, they hold elements together to make them easier to reference. Unlike divs, however, they don't come with any concept of formatting or sizing.

The grouping element has a class `histogram`, which we'll use later for styling, and uses the `transform` attribute to move into position via the `translate` property.

SVG transforms are a powerful tool in SVG drawing, but teaching you all about them goes beyond the scope of this book. We're only going to use the `translate()` property, which specifies a new `x, y` position for the given element.

We used ES6's string templates to create `transform`'s value. These are denoted with backticks and evaluate any JavaScript you put into `${}`. It's a great alternative to concatenating strings, but don't go crazy with these lest you won't understand what your code is doing six months from now when you have to fix a bug.

In this case, we're using this SVG transformation to give our Histogram some room to breathe. Exactly how much room comes from `this.props.topMargin` - a component property specified by whomever renders our `Histogram` component.

### d3.js for \[dataviz\] calculations

We're going to build our histogram with d3.js’s built-in histogram layout. It’s smart enough to do everything on its own. Data binning, calculating positions and dimension of histogram bars, and a few other useful tidbits. We just have to give it some data and some configuration.

We add three methods to our `Histogram` component to manage d3.js:

{crop-start-line=27,crop-end-line=47,linenos=off,lang=jsx}
<<[D3.js management functions](code_samples/es6/Histogram/Histogram.jsx)

In `constructor()` we create the d3 objects we need and give them any defaults we know about, in `componentWillReceiveProps()` we make sure to call `this.update_d3`, and `update_d3()` is the function that does our heavy lifting. It updates d3 objects with any new properties our component gets from above.

This is the cleanest approach I’ve found to make d3.js and React work together. We’ll use it for all of our d3.js-enabled components.

The problem we're facing is that d3.js achieves its declarative nature through objects. When you call a d3.js function, it's usually got some internal state.

This is great when you want to change how d3.js behaves by daisy-chaining getters and setters, but it causes problems with React. We have to make sure to keep that internal state up-to-date.

We *could* create new objects on every `render()`, but that feels wasteful. Maybe I'm just old fashioned.

This time `update_d3()` does its heavy lifting like this:

{crop-start-line=81,crop-end-line=98,linenos=off,lang=jsx}
<<[update_d3 function body](code_samples/es6/Histogram/Histogram.jsx)

If you’re used to d3.js, this code should look familiar. We updated the number of bins in our histogram with `.bins()` and gave it a new value accessor with `.value()`. This tells the layout how to get the interesting datapoint from our data objects.

{# this is a weird sentence #}
We’re doing one better by just passing in the function from our properties. This makes the `Histogram` component more reusable. The less we assume about what we’re doing, the better.

Then, we called `this.histogram()` to ask d3's histogram layout to do its magic. If you print the result in `bars`, you'll see it's an array of arrays that have some properties.

{title="Histogram printout",linenos=off}
	 // console.log(bars) in update_d3()
   [Array[26209], Array[48755], // ...]
    0: Array[26209]
       [0 … 9999]
       [10000 … 19999]
       [20000 … 26208]
       dx: 69999.273
       length: 26209
       x: 14.54
       y: 26209

Each array holds:
  - data for its respective histogram bin
  - a `dx` property for bar thickness
  - a `length`, which is the number of items in this bin
  - an `x` coordinate
  - a `y` coordinate

We'll use these to draw our histogram bars.

But before we can do that, we have to update our scales. You can think of scales as mathematical functions that map a domain to a range. Domain tells them the extent of our data; range tells them the extent of our drawing area. So if you have a linear scale with a domain `[0, 1]` and a range `[1, 2]` and you call `scale(0.5)`, you will get `1.5`.

To define the correct domains, we first got the `counts` of elements in each bin, then used `min`/`max` helpers to find smallest and largest values. In case of height, we had to add each bar's thickness to its position to find the max.

To define the ranges, we relied on chart dimension properties.

Notice how we use the `x` position to define the domain for our `yScale`? That's because our histogram is going to be horizontal.

We can do that so simply because scales don't care about anything, they just map a domain to a range. How you use that is up to you.

Scales are my favorite. You'll see why when we start drawing.

### React for the SVG output

Great, our scales are ready to help us draw, so let's add the drawing bit to `render()`.

{crop-start-line=151,crop-end-line=166,linenos=off,lang=jsx}
<<[Add histogram bars to SVG](code_samples/es6/Histogram/Histogram.jsx)

Even though we already calculated our histogram data in `update_d3()`, we calculate it again in `render()`. This lets us avoid using state and triggering unnecessary re-renders. It seems wasteful at first, but think about it: Which is quicker? Re-rendering twice on every prop change, or running a d3 function twice?

Ok, it's not immediately obvious which one uses less processing power, but we prefer avoiding state because it saves *our* brain cycles. Those are almost always more expensive than computer cycles.

We also added a new grouping element for the histogram bars. You'll see why we need a group inside a group later.

The more important bit is that we could just `.map()` through our histogram data even though we're technically inside XML. That's the magic of JSX - JavaScript and XML living together as one.

We could even have put the entire `makeBar` function in here, but that makes our code harder to read.

One last trick was using ES7's double-colon operator. This is syntax sugar for `this.makeBar.bind(this)`. Remember, we have to manually bind methods to `this` scope because we're using ES6 classes.

You can use this syntax sugar, if you [enabled `stage-0`](#enable-es7) in the chapter about your dev environment.

Now we need the `makeBar` method, it looks like this:

{crop-start-line=209,crop-end-line=227,linenos=off,lang=jsx}
<<[The makeBar helper method](code_samples/es6/Histogram/Histogram.jsx)

This code uses `Histogram`'s properties and scales to calculate attributes for each bar, then passes the `props` object to a subcomponent called `HistogramBar` using a spread - `{...props}`. React's implementation of the spread operator - `...` - is more powerful than the base ES6 spread because it supports objects, not just arrays and function arguments.

You can think of it as shorthand for writing `percent={percent} x={this.props.axisMargin} y={this.yScale(bar.x)} …`.

We could have generated the SVG for a bar with a label right here, but it's going to involve some logic so I think it makes more sense as a subcomponent.

Let’s add the `HistogramBar` component.

{crop-start-line=247,crop-end-line=278,linenos=off,lang=jsx}
<<[HistogramBar component](code_samples/es6/Histogram/Histogram.jsx)

There's nothing too special going here. Take some properties and return a grouping element with a rectangle and a text label.

Once more we used an ES6 string template to build the `transform` property, and we added some ad-hoc vertical padding to the bar to make it look better. We also used some ad-hoc calculations to place the `text` element at the end of the bar. This will make our histogram easier to read because every bar will have its percentage rendered on the crucial right edge.

Some bars are going to be too small to fit the whole label. Let's avoid rendering the label in those cases.

{crop-start-line=274,crop-end-line=290,linenos=off,lang=jsx}
<<[Adjust label for small bars](code_samples/es6/Histogram/Histogram.jsx)

We add some decimal points if we’re showing small numbers, and completely remove the label when there isn't enough room.

### Adding Histogram to the main component

Despite our magnificent `Histogram` component, the page is still blank. We have to go back to `H1BGraph/index.jsx` and tell `H1BGraph` to render the component we've just made.

First we have to import our `Histogram` component at the top of `H1Bgraph/index.jsx`. Like this:

{crop-start-line=268,crop-end-line=274,linenos=off,lang=jsx}
<<[Require Histogram](code_samples/es6/H1BGraph/index.jsx)

The reason this works so well is that `Histogram/index.jsx` file we created, which lets us `import` a directory instead of worrying about specific files inside it.

Then, we can add the histogram component to our `render` method.

{crop-start-line=317,crop-end-line=347,linenos=off,lang=jsx}
<<[Render the histogram component](code_samples/es6/H1BGraph/index.jsx)

We use a `params` dictionary with our dimensions attributes, number of bins in the histogram, and the value accessor function. This makes our code cleaner and thus easier to read.

Inside the `return` statement, we made sure our `<svg>` element has a width and a height, and added the `<Histogram .. />` component. Once more we used the spread trick to feed it many `params` at once. We kept `data` as a separate attribute to make it more apparent that this component uses data.

If you kept `npm start` running, your browser should show something like this:

![Unstyled Histogram](images/unstyled_histogram.png)

So much effort to render those labels and you can't even see them. Let's add some styling to `src/Histogram/style.less` to make the Histogram prettier:

{crop-start-line=5,crop-end-line=19,linenos=off,lang=less}
<<[style.less](code_samples/style.less)

And make sure we `require` the styles in `H1Bgraph/index.jsx`:

{crop-start-line=360,crop-end-line=365,linenos=off,lang=jsx}
<<[Require style.less](code_samples/es6/H1BGraph/index.jsx)

You should now see a histogram like this:

![Basic Histogram](images/base_histogram.png)

## Adding an axis

Axes are one of my favourite feats of d3.js magic. You call a function, set some parameters, and **BAM**, you’ve got an axis.

The axis automatically adapts to your data, draws the ticks it needs, and labels them. Axes are even smart enough to work with different types of scales. You don’t have to do anything special to turn a linear axis into a logarithmic axis.

These are complex objects, and recreating them in React would be silly. We’re going to use a dirty trick and give d3.js control of the DOM just this once.

Let’s start with a blank component that’s got function stubs for d3.js integration. Put it in `src/drawers.jsx`.

{crop-start-line=232,crop-end-line=252,linenos=off,lang=jsx}
<<[Axis component with function stubs](code_samples/drawers.jsx)

Even though we’re going to let d3.js handle DOM changes, we still have to return *something* in `render`. A grouping element that moves the resulting axis into position is the perfect candidate.

Now, let’s set some axis defaults in `componentWillMount`:

{crop-start-line=257,crop-end-line=270,linenos=off,lang=jsx}
<<[Axis default properties](code_samples/drawers.jsx)

We created a scale and an axis. The axis will use our linear scale, will be oriented to the left, and is going to prepend a dollar sign to the scale’s default tick formatter.

Yes, scales have tick formatters. It’s awesome.

In `update_d3`, we have to make sure things stay up-to-date:

{crop-start-line=309,crop-end-line=324,linenos=off,lang=jsx}
<<[Update axis state](code_samples/drawers.jsx)

Just like the previous section, we had to tell `yScale` the extent of our data and drawing area. Conversely, we didn’t have to tell any of this to the axis. It already knows because we updated the scale.

We *did* have to get around a great deal of the axis’s smartness. We gave it the exact number of ticks we want and the exact values they should show. This is because we wanted every bar in the histogram to have a corresponding label on the axis.

Finally, here comes the dirty trick:

{crop-start-line=369,crop-end-line=381,linenos=off,lang=jsx}
<<[The dirty trick](code_samples/drawers.jsx)

I’m sure this goes against everything React designers fought for, but it works. We hook into the `componentDidUpdate` and `componentDidMount` callbacks with a `renderAxis` method. Then, we use `this.getDOMNode()` to get a reference to the rendered element, feed it into `d3.select()`, and `.call()` the axis on it.

What we’re doing is basically throwing away the whole element and creating it from scratch on every render. It's rather inefficient, but it’s okay when used sparingly.

Now we have to add some styling and make sure the axis is included somewhere.

The styling goes into `src/style.less`:

{crop-start-line=23,crop-end-line=46,linenos=off,lang=less}
<<[Styling the axis](code_samples/style.less)

And it makes to render our axis in `Histogram.render`:

{crop-start-line=446,crop-end-line=459,linenos=off,lang=jsx}
<<[Add Axis to Histogram.render](code_samples/drawers.jsx)

That’s it. Your histogram should look like this:

![Histogram with axis](images/axis_histogram.png)

## Reacting to data changes

We’ve got a histogram with an axis and the building blocks to make as many as we want. Awesome!

But our histogram looks weird. Most of our data falls into the first three bars and a lone outlier stretches the data range far too much.

Sure, we could take care of this by removing the outlier, but let's be honest: statisticians should worry about statistical anomalies. We’re here to draw pictures.

The next best thing is letting users filter data and take a closer look. This solves our problem of finding outliers, and it gives users more freedom. And maybe, just maybe, they’re going to spend more time on our site.

Win-win-win.

We’re going to make controls that let users filter data by year. In the full example, I added filtering by state and job title as well, but they follow the same principles and talking about them here would take too long.

![Events flow up through callbacks](images/architecture_events.jpg)

Our approach will follow the approach of having events flow up the hierarchy and having data updates flow down. When a user clicks a button, it calls a function on its parent. This in turn calls a function on its parent and so on until we hit `H1BGraph`, which is our holder of truth.

We could also call functions directly on `H1BGraph` if we had a reference to them, but that would break the separation of concerns in our case.

Once `H1BGraph` updates its state, the changed data flows back down to the relevant components via `props`.

![Updated data flows back down](images/architecture_updates.jpg)

### Creating user controls

We're going to organise our controls into three components:

* `Controls`, which holds the controls together
* `ControlRow`, which is a row of buttons
* `Toggle`, which is a toggle-able button

Let’s start a new file called `src/controls.jsx` with a `Controls` component stub:

{crop-start-line=5,crop-end-line=19,linenos=off,lang=jsx}
<<[Controls component stub](code_samples/controls.jsx)

We’re going to need React and Lodash in this file, and Controls is the only component we’ll expose to the outside.

Let’s add all of this to the main `H1BGraph` component. It’s just three lines inside `render`:

{crop-start-line=366,crop-end-line=381,linenos=off,lang=jsx}
<<[Add Controls to H1BGraph.render](code_samples/main.jsx)

We had to wrap everything in another `<div>` because React throws a hissy fit if we try to return multiple elements side-by-side. We used props to give the `Controls` component some data and the filter update callback.

Don’t forget to add `Controls = require('./controls.jsx')` somewhere near the top of the file.

You should have some empty components showing up on the screen. Let’s add the row of buttons to the `Controls.render` method:

{crop-start-line=24,crop-end-line=47,linenos=off,lang=jsx}
<<[Render a ControlRow](code_samples/controls.jsx)

This will break in your browser because we don’t have a `ControlRow` component yet. The idea is to have a component that takes data, a function that generates the button labels, and an `updateDataFilter` callback.

We’ll define the callback later. Let’s make the `ControlRow` component first.

{crop-start-line=51,crop-end-line=72,linenos=off,lang=jsx}
<<[ControlRow component](code_samples/controls.jsx)

There's nothing special going on here. We’ve got a `render` method that returns a Bootstrap row and fills it with a bunch of `Toggle` components. It does so by looping over the result of `this.props.getToggleNames`, which is the function we defined in `Controls.render`.

Normally, `onClick` is a click event handler. React gives us this sort of magic prop for every valid user event. It’s the same as jQuery’s `$('foo').on('click')`.

They only work on HTML elements, not React components, so this one is just a function callback that we’ll use manually.

We had to define the `key` property to help React identify specific elements. I assume it uses these to identify which elements to re-render if they’re created in a loop.

We've also got a `value` property that comes out of `this.state.toggleValues`. It tells our toggles whether to render as turned on or off. We track this state in `ControlRow` instead of just the `Toggle` itself, so we can make sure only one turns on at the time.

Let’s add the state handling.

{crop-start-line=77,crop-end-line=100,linenos=off,lang=jsx}
<<[Exclusive toggling](code_samples/controls.jsx)

The `makePick` function is called when the user clicks on a `Toggle` element. It goes through the `toggleValues` dictionary and sets them to `false` if they aren't the one the user clicked on. The one they did click is set to `true`.

Then it saves the dictionary with `this.setState`, which triggers a re-render and updates all the buttons.

We used the trusty `getInitialState` to create the `toggleValues` dictionary with everything set to `false`.

Now we need the `Toggle` component.

{crop-start-line=124,crop-end-line=146,linenos=off,lang=jsx}
<<[Toggle component](code_samples/controls.jsx)

Toggle renders a button. If `this.state.value` is `true`, then the button is highlighted. We set it to off by default and update it when `componentWillReceiveProps` triggers. That happens when the component’s properties change from above.

Now your page shows three buttons under the histogram:

![Histogram with buttons](images/buttons_histogram.png)

But clicking on a button will throw an error.

### Propagating events up the hierarchy

To make the buttons work, we have to implement the click event handler - `this.handleClick`. Then we have to call every callback up the chain until we get to the histogram component, which is our holder of truth.

Let’s start by adding a click handler to the `Toggle` component:

{crop-start-line=151,crop-end-line=163,linenos=off,lang=jsx}
<<[Toggle click handler](code_samples/controls.jsx)

It's a simple function. All it cares about is toggling the `value` state and calling the `this.props.onClick` callback.

The reason we’re using state to highlight the button is that making this change optimistically instead of waiting for propagation looks better to the user. It’s a tiny bit more instant, which makes our app feel faster.

We still override the `value` in `componentWillReceiveProps`, if the parent component wants us to.

If you click around now, the buttons are going to toggle on and off. `ControlRow` will continue making sure you can only choose one at a time.

![2013 toggled on](images/togglable_buttons.png)

To make these changes propagate further than `ControlRow`, we have to call `ControlRow`'s callback in the `makePick` method:

{crop-start-line=185,crop-end-line=200,linenos=off,lang=jsx}
<<[Callback in ControlRow.makePick](code_samples/controls.jsx)

Nothing fancy, just a call to `this.props.updateDataFilter` with information on what was picked and whether we want to reset the filter or not. The reset is used when the user clicks on a button that’s already turned on.

Now comes the fun part. We get to construct the data filter in our `Controls` component, then tell the main `H1BGraph` component.

We gave `this.updateYearFilter` as the update callback to `ControlRow`. It’s a simple function that creates a filter function based on the chosen year and saves it with `setState()` like this:

{crop-start-line=255,crop-end-line=274,linenos=off,lang=jsx}
<<[Controls.updateYearFilter function](code_samples/controls.jsx)

We also added the `getInitialState` function to make sure the filter is set to an "accept everything" version by default.

Our next step is to tell the parent component about our new filter.

{crop-start-line=348,crop-end-line=368,linenos=off,lang=jsx}
<<[Propagating filter up the chain](code_samples/controls.jsx)

React calls `componentDidUpdate` when we change the state. This gives us a great opportunity to call our filter callback - `this.props.updateDataFilter`. We feed it a new filter function that combines all of the potential filters in our state. In our trimmed-down example, our only filter is `yearFilter`.

You’d think we could do all of this straight in the `updateYearFilter` function, but we don’t have access to the updated state yet. Because we might add more types of filters later, it’s better to rely on the already saved filters.

Ok, we’ve just created an infinite loop. When `componentDidUpdate` is called we call something on the parent component. This potentially changes our `props`, which again triggers `componentDidUpdate`.

We have to make sure the component updates *only* when properties have actually changed. The easiest way to do that is using `shouldComponentUpdate`. If it returns `false`, the component doesn’t update.

Anyway, it’s time to add the filtering functionality to `H1BGraph`.

{crop-start-line=422,crop-end-line=435,linenos=off,lang=jsx}
<<[Filter update callback in H1BGraph](code_samples/main.jsx)

Nothing fancy. We initially set the `dataFilter` to accept everything and update it when something calls `updateDataFilter` with a new filter function.

The last step is filtering the data in our `H1BGraph.render` method.

{crop-start-line=530,crop-end-line=552,linenos=off,lang=jsx}
<<[Filter data in H1BGraph.render](code_samples/main.jsx)

As you can see, we didn’t have to do much. We passed the `rawData` through our filter before feeding it to the `Histogram`.

You should now see a histogram like this:

![Histogram with only 2014 salaries](images/2014_histogram.png)

Hooray! We have a histogram with user filtering.

A lot of work went into that, and we’ve got plenty of moving parts. But remember, all it takes to add more filters is adding another `<ControlRow />` to `Controls`, writing a filter function, and making sure it’s included in `updateDataFilter`.

That’s it. A minute of typing to let users filter by almost anything.

## Adding some meta data

If you’ve followed along this far, you’ve got a nice histogram of H1B salaries in the software industry. It renders fully on the front-end and changes when the user picks a specific year. You’ve even got a couple of building blocks to make it better.

But a good visualization needs a title and a description. The title tells users what they’re looking at, and the description gives them the story.

As great as people are at understanding pictures, it goes much better when you flat-out *tell* them what they’re looking at.

We start with a stubbed out `src/meta.jsx` file:

{crop-start-line=5,crop-end-line=32,linenos=off,lang=jsx}
<<[Stubbed meta.jsx file](code_samples/meta.jsx)

We’re going to make a mixin called `MetaMixin` because both the `Title` and `Description` components are going to use some of the same functions. It will have a function to get a list of years out of the data, a function to give us a label formatter, and a function to give us data filtered by a specific year.

Let’s add them.

{crop-start-line=37,crop-end-line=63,linenos=off,lang=jsx}
<<[MetaMixin functions](code_samples/meta.jsx)

There’s nothing special going on here. `getYears` uses `_.groupBy` to group the data by year, then returns the keys of the array. We could make this more efficient, but it works well enough and is easy to read.

`getFormatter` relies on the fact that d3.js scales have formatters. It creates a linear scale with a domain and returns the `tickFormat()` function. Formatters don't work well without a defined domain.

`getAllDataByYear` is a simple filter function. We’ll use it to access data for specific years when making the description.

To keep our meta data code clean, we've also got a file that maps state abbreviations to names. It's called `src/states.jsx` and exports an object that looks like this:

{linenos=no}
   module.exports = {
      "AL": "Alabama",
      "AK": "Alaska",
      // ...

You can build your own, or you can [get it from Github](https://github.com/Swizec/h1b-software-salaries/blob/master/src/states.js).

Let’s start with the title.

### The title

Our titles are going to follow a formula like: “H1B workers in the software industry made $x/year in <year>”.

We start with the year fragment:

{crop-start-line=68,crop-end-line=83,linenos=off,lang=jsx}
<<[getYearsFragment function](code_samples/meta.jsx)

We get the list of years in the current data and return either an empty string or `in Year`. If there’s only one year in the data, we assume it’s been filtered by year.

The `render` function is going to be simple as well:

{crop-start-line=110,crop-end-line=129,linenos=off,lang=jsx}
<<[Title.render function](code_samples/meta.jsx)

We’re returning an `<h2>` element with a title that includes some dynamic tags. We change `made` to `make` based on whether or not we’re adding `in years`, and we used `d3.mean` to get the average.

Now we can add the title into H1BGraph’s render method. You can use as many as you want, wherever you want, but I think putting it above the graph works best.

{crop-start-line=622,crop-end-line=636,linenos=off,lang=jsx}
<<[Add title to H1BGraph.render](code_samples/main.jsx)

Don’t forget to add a `meta = require(‘./meta.jsx’);` at the top of the `src/main.jsx`.

Your histogram should now look like this:

![Histogram with title](images/titled_histogram.png)

Now let’s add a paragraph of description to make the story clearer.

### The description

Our descriptions won’t be much more complicated than the titles. We'll need a sentence or two explaining what the histogram is showing and comparing it to the previous year.

First, we add the `getYearFragment` function:

{crop-start-line=134,crop-end-line=150,linenos=off,lang=jsx}
<<[Description.getYearFragment function](code_samples/meta.jsx)

It's the same as in `Title`, but with a capital first letter. Yes, this might fit better in `MetaMixin`.

But the `getPreviousYearFragment` function is more complex:

{title="Description.getPreviousYearFragment",linenos=off,lang=jsx}
    getPreviousYearFragment: function () {
        var years = this.getYears().map(Number),
            fragment;

        if (years.length > 1) {
            fragment = "";
        }else if (years[0] == 2012) {
            fragment = "";
        }else{
            var year = years[0],
                lastYear = this.getAllDataByYear(year-1),
                percent = ((1-lastYear.length/this.props.data.length)*100).toFixed();

            fragment = ", "+Math.abs(percent)+"% "+(percent > 0 ? "more" : "less")+" than the year before";
        }

        return fragment;
    },

First, we get the list of years. If it’s empty or the current year is 2012 (the first in our dataset), we return an empty fragment.

In any other case, we get a look at last year’s data with `this.getAllDataByYear()`. We can then compare the number of entries with this year and return a fragment that’s either “X% **more** than the year before” or “X% **less** than the year before”.

Now we’ve just got to use these two fragments in the render method.

{crop-start-line=238,crop-end-line=256,linenos=off,lang=jsx}
<<[Description.render function](code_samples/meta.jsx)

We’ve crammed a bunch into that return statement, but it's not as hairy as it looks. We start the sentence with either “Since 2012” or “In Year”, then decide what tense to use for the verb “give”, followed by the count of H1Bs in the current data and “foreign nationals”.

Right after that, with no space, we add the previous year fragment. Then we add a sentence describing the range that the majority of salaries fall into. To get the numbers, we used d3.js’s built-in standard deviation calculator and assumed the distribution is roughly normal. That means 68.2% of our data falls within a standard deviation to each side of the mean.

Yes, my statistics professor would be very angry, but it’s a good-enough approximation.

Let’s put the description next to our title.

{crop-start-line=707,crop-end-line=722,linenos=off,lang=jsx}
<<[Add description to H1BGraph.render](code_samples/main.jsx)

Unlike the title, our description needs the full data just like the controls do. Without this, it wouldn't be able to get data for previous years.

Your histogram should now have a nice description:

![Histogram with description](images/description_histogram.png)

Hooray, you’ve made a histogram of H1B salaries with a title and description that both change when the visualization changes. You’re awesome!

Now you know how to make React and d3.js work together. Yay!
