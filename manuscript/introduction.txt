# Introduction

I wrote this book for you as an experiment. The theory we’re testing is that technical content works better as a short e-book than as a long blog post.

You see, the issue with technical blogging is that posts live and die by their length. As soon as you surpass 700 words, everything falls apart. Readers wander off to a different tab in search of other material, never to be seen or commented from again.

This sucks for me as a writer, but more importantly, it sucks for you as a reader. You’re not going to learn something if you don’t finish reading.

So here we both are.

I’m counting on you to take some time away from the internet, to truly sit down and read. I'm counting on you to follow the examples. I'm counting on you to *learn*.

You’re counting on me to have invested more time, effort, and care in crafting this than I would have invested in a blog post. I have.

I’ve tried to keep this book as concise as possible. iA Writer estimates it will take you about an hour to read *React+d3.js* in its entirety, but playing with the examples could add some time to that.

## Why you should read React+d3.js

After an hour with *React+d3.js*, you’ll know how to make React and d3.js play together. You’ll know how to create composable data visualizations. You’re going to understand *why* that’s a good idea, and you will have the tools to build your own library of reusable visualization parts.

Ultimately, you’re going to understand whether React and d3.js fit the needs of your project.

## What you need to know

I’m going to assume you already know how to code and that you’re great with JavaScript. Many books have been written to teach the basics of JavaScript; this is not one of them.

I’m also going to assume some knowledge of d3.js. Since it isn’t a widely-used library, I’m still going to explain the specific bits that we use. If you want to learn d3.js in depth, you should read my book, [Data Visualization with d3.js](https://www.packtpub.com/web-development/data-visualization-d3js).

React is still a new kid on the block, so I’m going to assume you're not quite as familiar with it. We’re not going to talk about all the details, but you’ll be fine, even if this is your first time looking at React.

## How to read this book

Relax. Breathe. You’re here to learn. I’m here to teach. I promise Twitter and Facebook will still be there when we get done.

Just you and some fun code. To get the most out of this material, I suggest two things:

1. Try the example code yourself. Don’t just copy-paste; type it and execute it. Execute it frequently. If something doesn’t fit together, look at the full working project on Github [here](https://github.com/Swizec/h1b-software-salaries), or check out the zip files that came with the book.
2. If you already know something, skip that section. You’re awesome. Thanks for making this easier for me.

React+d3.js is heavily based on code samples. They look like this:

{linenos=off,lang=jsx}
     var foo = 'bar';

Added code looks like this:

{linenos=off,lang=jsx}
     var foo = 'bar’;
     // leanpub-start-insert
     foo += 'this is added’;
     // leanpub-end-insert

Removed code looks like this:

{linenos=off,lang=jsx}
     var foo = 'bar';
     // leanpub-start-delete
     foo += 'this is added';
     // leanpub-end-delete

## ES5 and ES6 versions

This book comes in two versions: ES5 and ES6. They are functionally the same, but they use different versions of JavaScript for their code samples. The ES6 version also has a cleaner (but more complicated) file structure.

You can read either version depending on which version of JavaScript you're more comfortable with.

# Why React and d3.js

React is Facebook's and Instagram's approach to writing modern JavaScript front-ends. It encourages building an app out of small, re-usable components. Each component is self-contained and only needs to know how to render a small bit of the interface.

The catch is that many frameworks have attempted this: everything from Angular to Backbone and jQuery plugins. But where jQuery plugins quickly become messy, Angular depends too much on HTML structure, and Backbone needs a lot of boilerplate, React has found a sweet spot.

I have found it a joy to use. Using React was the first time I have ever been able to move a piece of HTML without having to change any JavaScript.

D3.js is Mike Bostock’s infamous data visualization library. It's being used by The New York Times along with many other sites. It is the workhorse of data visualization on the web, and many charting libraries out there are based on it.

But d3.js is a fairly low-level library. You can’t just say *"I have data; give me a bar chart"*. Well, you can, but it takes a few more lines of code than that. Once you get used to it though, d3.js is a joy to use.

Just like React, d3.js is declarative. You tell it *what* you want instead of *how* you want it. It gives you access straight to the SVG so you can manipulate your lines and rectangles at will. The issue is that d3.js isn't that great if all you want are charts.

This is where React comes in. For instance, once you’ve created a histogram component, you can always get a histogram with `<Histogram {...params} />`.

Doesn’t that sound like the best? I think it's pretty amazing.

It gets even better. With React, you can make various graph and chart components build off the same data. This means that when your data changes, the whole visualization reacts.

Your graph changes. The title changes. The description changes. Everything changes. Mind = blown.

Look how this H1B salary visualization changes when the user picks a subset of the data to look at.

![Default H1B histogram](images/full_default_h1b.png)

![Changes after user picks a data subset](images/full_changed_h1b.png)

React + d3.js: a powerful combination indeed.

## JSX

We’re going to write our code in JSX, a JavaScript syntax extension that lets us treat XML-like data as normal code. You can use React without JSX, but I feel that it makes React’s full power easier to use.

The gist of JSX is that we can use any XML-like string just like it is part of JavaScript. No Mustache or messy string concatenation necessary. Your functions can return straight-up HTML, SVG, or XML.

For instance, the code that renders our whole application is going to look like this:

{crop-start-line=399,crop-end-line=402,linenos=off,lang=jsx}
<<[A basic Render](code_samples/old/main.jsx)

Which compiles to:

{title="JSX compile result", linenos=off, lang=js}
    React.render(
        React.createElement(H1BGraph, {url: “data/h1bs.csv”}),
        document.querySelectorAll(‘.h1bgraph’)[0]
    );

As you can see, HTML code translates to `React.createElement` calls with attributes translated into a property dictionary. The beauty of this approach is two-pronged: you can use React components as if they were HTML tags and HTML attributes can be anything.

You’ll see that anything from a simple value to a function or an object works equally well.

I'm not sure yet whether this is better than separate template files in Mustache or whatever. There are benefits to both approaches. I mean, would you let a designer write the HTML inside your JavaScript files? I wouldn't, but it's definitely better than manually `+`-ing strings or Angular's approach of putting everything into HTML. Considerably better.

If you skipped the setup section and don't have a JSX compilation system set up, you should do that now. You can also use the project stub you got with the book.
