# Speed optimizations #

Welcome to the section on speed optimizations. This is where we make our code harder to read and faster to run.

You might never need any of the techniques discussed here. You already know how to build performant data visualization components. For 99% of applications, plain code that's easy to read and understand is plenty fast.

Do you really need to save that tenth of a second at runtime and spend an extra hour of thinking every time there's a bug?

Be honest. ;)

That said, there are cases where faster code is also easier to read. And there are cases where your visualization is so massive, that you need every ounce of oomph you can get.

For the most part, we're going to talk about three things:

- using canvas to speed up rendering
- using React-like libraries to speed up the core library
- avoiding unnecessary computation and redraws

We'll start with canvas because it's the biggest speed improvement you can make.

# Using canvas

We've been using SVG to render our apps so far. SVG is great because it follows a familiar structure, offers infinitely scalable vector graphics, and works pretty much everywhere. Sure you can't use some fancy SVG features on all browsers, but the basics are solid.

However, SVG has a big flaw: it's slow.

Anything more than a few hundred SVG nodes and your browser will struggle. Especially if you want to animate those thousands of elements.

A panelist at ForwardJS once asked me *"But why would you want that?"*. It was my first time participating in a panel and my answer sucked. Here's the real answer: *"Because there have been thousands of UFO sightings, there are thousands of counties in the US, millions of taxi rides, hundreds of millions of people having this or that datapoint. And you want to show change over time"*

That's the real answer. Sometimes, when you're visualizing some data, you have a lot of data. The data changes over time, and animation is the best way to show changes over time.

Once upon a time I worked on a [D3 video course](https://www.packtpub.com/web-development/mastering-d3js-video) for Packt and used UFO sightings as an example. At peak UFO sighting, right before smartphones become a thing, the animation takes up to 2 seconds to redraw a single frame. 

It's terrible.

So if SVG is slow and you need to animate thousands of elements, what are you to do? HTML5 Canvas.

## Why canvas

Unlike SVG, HTML5 Canvas lets you draw rasterized images. This means you're not longer operating at the level of shapes, you're working with pixels on the screen.

With SVG, you tell the browser *what* you want to render. With canvas, you tell the browser *how* you want to render. The browser doesn't know what you're doing, it just gets a field of pixel colors and renders them as an image.

As a result, browsers can use the GPU to render canvas. With a bit of care, you can do almost anything you want even on a mobile phone.

Phones these days have amazing GPUs and kind of terrible CPUs. That's why I'd almost suggest going straight to canvas for any sort of complex animation. Mobile traffic is, what, 60% or even 70% of traffic these days?

Now you might be thinking this sounds complicated. How do you know which pixel should do what when you're rendering with canvas? Sounds like a lot of work.

HTML5 Canvas does offer some shape primitives. It has circles and rectangles and things like that, but they suffer from the same problem that SVG does. The browser has to use your CPU to calculate those and at around 10,000 elements things break down.

Notice that 10,000 elements is still a hell of a lot more than the 3,000 or so that SVG gives you.

If your app allows it, you can use sprites. Tiny images copy pasted on the canvas as bytestreams. I have yet to find an upper bound for those. My JavaScript became the bottleneck :D

But I'm getting ahead of myself, we'll talk about sprites later.

## The trouble with HTML5 Canvas

A tricky thing with HTML5 Canvas is that the API is low level and that canvas is flat. As far as your JavaScript and React code are concerned, it's a flat image. Could be anything.

There's no structure, which makes it difficult to detect clicks on elements, interactions between elements, when something covers something else, how the user interacts with your stuff and things like that. You have to move most of that logic into your data store and manually keep track.

You can imagine this becomes cumbersome. And you still can't detect user interaction because all you get is *"User clicked on  coordinate (x, y). Have fun"*.

At the same time, the low level API makes abstractions difficult. You can't create components for "this is a map" or "histogram goes here". You're always down to circles and rectangles and basic shapes at best.

Your code can soon start looking much like the D3.js spaghetti we wanted to avoid in the first place.

# Declarative HTML5 Canvas with Konva and react-konva

Enter [Konva](https://konvajs.github.io) and react-konva. All the benefits of declarative code, but rendered on the canvas.

I'm gonna let Anton Lavrenov, the author of Konva, explain:

> Konva is an HTML5 Canvas JavaScript framework that enables high performance animations, transitions, node nesting, layering, filtering, caching, event handling for desktop and mobile applications, and much more.

> You can draw things onto the stage, add event listeners to them, move them, scale them, and rotate them independently from other shapes to support high performance animations, even if your application uses thousands of shapes. Served hot with a side of awesomeness.

That. 

It's exactly what we need to push our animated React apps to thousands of elements. Without spending too much time thinking about the *how* of rendering. Best leave the hairy details to somebody else.

Let me show you two examples.

1. Pushing our particle generator to 20,000 elements
2. An n-body collision simulator built with MobX

{#canvas-react-redux}
## A particle generator pushed to 20,000 elements with canvas

Our [SVG-based particle generator](#animating-react-redux) caps out at a few thousand elements. Animation becomes slow and time between each iteration of our game loop increases.

Old elements leave the screen and get pruned faster than we can create new ones. This creates a natural (but stochastic) upper limit to how many elements we can push into the page.

We can render many more elements, if we take out SVG and use HTML5 Canvas instead. I was able to push the code up to around 20,000 smoothly animated elements. Then JavaScript became the bottleneck.

Well, I say JavaScript was the bottleneck, but monitor size plays a role too. It goes up to 20,000 on my laptop screen, juuuust grazes 30,000 on my large desktop monitor, and averages about 17,000 on my iPhone 5SE.

Friends with newer laptops got it up to 35,000.

You can see it in action hosted on [Github pages](http://swizec.github.io/react-particles-experiment/).

We're going to keep most of our code from before. The real changes happen in `src/components/index.jsx` where a Konva stage replaces the `<svg>` element, and in `src/components/Particles.jsx` where we change what we render. There's a small tweak in the `CREATER_PARTICLES` reducer to generate more particles on each tick.

If anything looks weird or doesn't work, I've prepared a helpful [GitHub branch](https://github.com/Swizec/react-particles-experiment/tree/canvas-based-branch) for you.

You should go into your particle generator directory, install  Konva and react-konva, then make the changes below. Trying things out is better than just reading my code ;)

```
$ npm install --save konva react-konva
```

{aside}
react-konva is a thin wrapper on Konva itself. There's no need to think about it as its own thing. For the most part, you can go into the Konva docs, read about something, and it Just Works in react-konva.
{/aside}

### Preparing a canvas layer

Our changes start in `src/components/index.jsx`. We have to throw away the `<svg>` element and replace it with a Konva stage.

You can think of a Konva stage as a canvas element with a bunch of helper methods attached. Some of them Konva uses internally, others are exposed as an API. Functions like exporting to an image file, detecting intersections, etc.

{caption: "Import Konva and set the stage"}
```javascript
// src/components/index.jsx

// ...
import { Stage } from 'react-konva';

// ...
class App extends Component {
    // ..
    render() {
        return (
            // ..
                     <Stage width={this.props.svgWidth} height={this.props.svgHeight}>
                         <Particles particles={this.props.particles} />

                     </Stage>

                 </div>
                 <Footer N={this.props.particles.length} />
             </div>
        );
    }
}
```

We import `Stage` from `react-konva`, then use it instead of the `<svg>` element in the `render` method. It gets a `width` and a `height`.

Inside, we render the `Particles` component. It's going to create a Konva Layer and use low-level canvas methods to render particles as sprites.

### Using sprites for max redraw speed

Our [SVG-based Particles](#svg-particles) component was simple. Iterate through a list of particles, render a `<Particle>` component for each.

We're going to completely rewrite it.

Our new approach goes like this:

0. Cache a sprite on `componentDidMount`
1. Clear canvas
2. Redraw all particles
3. Repeat

Because the new approach renders a flat image and because we don't care about interaction with individual particles, we can get rid of the `Particle` component. The unnecessary layer of nesting was slowing us down.

The new `Particles` component looks like this:

{caption: "Sprite-based Particles component"}
```javascript
// src/components/Particles.jsx

import React, { Component } from 'react';
import { FastLayer } from 'react-konva';

class Particles extends Component {
    componentDidMount() {
        this.canvas = this.refs.layer.canvas._canvas;
        this.context = this.canvas.getContext('2d');

        this.sprite = new Image();
        this.sprite.src = 'http://i.imgur.com/m5l6lhr.png';
    }

    drawParticle(particle) {
        let { x, y } = particle;

        this.context.drawImage(this.sprite, 0, 0, 128, 128, x, y, 15, 15);
    }

    componentDidUpdate() {
        let particles = this.props.particles;

        console.time('drawing');
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (let i = 0; i < particles.length; i++) {
            this.drawParticle(particles[i]);
        }
        console.timeEnd('drawing');
    }

    render() {
        return (
            <FastLayer ref="layer" transformsEnabled="position" listening="false">

            </FastLayer>
        );
    }
}

export default Particles;
```

40 lines of code is a lot to look at all at once. Let's walk through it step by step.

#### componentDidMount

{caption: "componentDidMount code"}
```javascript
// src/components/Particles.jsx

// ...
componentDidMount() {
    this.canvas = this.refs.layer.canvas._canvas;
    this.context = this.canvas.getContext('2d');

    this.sprite = new Image();
    this.sprite.src = 'http://i.imgur.com/m5l6lhr.png';
}
```

This is a lifecycle hook that React calls when our component first renders. We use it to set up 3 instance properties.

`this.canvas` is a reference to the HTML5 Canvas element. We get it via a ref to the Konva layer, then spelunk through properties to get the canvas itself. As you can see by the `_` prefix, Anton Lavrenov did not intend this to be a public API.

Thanks to JavaScript's permissiveness we can use it anyway.

`this.context` is a reference to our canvas's CanvasRenderingContext2D. It's the interface we use to draw basic shapes, perform transformations, etc. Context is basically the only part of canvas you ever interact with as a developer.

Why it can't be just canvas, I don't know. 

`this.sprite` is a cached image. A small minion that we are going to copy paste all over the place as our particle. Using a combination of `new Image()` and setting the `src` property, loads it into memory as an HTML5 Image object.

It looks like this:

![Our minion particle](http://i.imgur.com/m5l6lhr.png)

You might be thinking that it's unsafe to copy references to rendered elements into component properties like that, but it's okay. Our render function always renders the same thing, so the reference never changes. Copying them like this means less typing.

#### drawParticle

{caption: "drawParticle code"}
```javascript
// src/components/Particles.jsx

// ...
drawParticle(particle) {
    let { x, y } = particle;

    this.context.drawImage(this.sprite, 0, 0, 128, 128, x, y, 15, 15);
}
```

This function draws a single particle on the canvas. It gets coordinates from the `particle` and uses `drawImage` to copy our sprite into position.

We use the whole sprite, corner `(0, 0)` to corner `(128, 128)`. That's how big our sprite is by the way. And we copy it to position `(x, y)` with a width and height of `15` pixels.

`drawImage` is the fastest method I've found to put pixels on canvas. I don't know why it's so fast, but here's a [helpful benchmark](https://jsperf.com/canvas-drawimage-vs-putimagedata/3) so you can see for yourself.

#### componentDidUpdate

{caption: "componentDidUpdate code"}
```javascript
// src/components/Particles.jsx

// ...
componentDidUpdate() {
    let particles = this.props.particles;

    console.time('drawing');
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    for (let i = 0; i < particles.length; i++) {
        this.drawParticle(particles[i]);
    }
    console.timeEnd('drawing');
}
```

`componentDidUpdate` is where the real particle drawing happens.  React calls this method every time our list of particles changes. *After* the `render` method.

Yes, we're moving rendering out of the `render` method and into `componentDidUpdate`.

Here's how it works:

1. `this.context.clearRect` clears the entire canvas. From coordinate `(0, 0)` to coordinate `(width, height)`. We delete everything and make the canvas transparent.
2. We iterate our `particles` list with a for loop and call `drawParticle` on each element.

Clearing and redrawing the canvas is faster than moving individual particles. For loops are faster than `.map` or any other form of iteration. I tested.

You can open your browser console to see how long it takes to draw a frame. That's why I left `console.time` and `console.timeEnd` in the code.

{aside}
`console.time` starts a timer and `timeEnd` stops it and prints the difference. I was super happy when someone told me about it during one of my livecoding sessions.
{/aside}

#### render

{caption: "render code"}
```javascript
// src/components/Particles.jsx

// ...
render() {
    return (
        <FastLayer ref="layer" transformsEnabled="position" listening="false">

        </FastLayer>
    );
}
```

After all that work, our `render` method is pretty simple. We render a Konva `FastLayer`, give it a `ref`, enable `position` transforms – I can't remember why to be honest, might be a leftover from experimenting – and turn off `listening` for mouse events.

Ideas for this combination of settings came from Konva's official [performance tips](https://konvajs.github.io/docs/performance/All_Performance_Tips.html) documentation. I don't understand Konva enough to know *why* this helps, but it makes sense when you think about it.

A `FastLayer` is faster than a `Layer`. It's in the name. Ignoring mouse events means you don't have to keep track of elements. It reduces computation.

All I know is that this was empirically the fastest solution that lead to the most particles on screen. ¯\_(ツ)_/¯

### But why, Swizec?

I'm glad you asked. This was a silly example. I devised the experiment because at my first React+D3 workshop somebody asked *"What if we have thousands of datapoints and we want to animate all of them?"*. I didn't have a good answer.

Now I do. You put them in canvas. You drive the animation with a game loop. You are god.

You can even do it as an overlay. Have an SVG for your graphs and charts, overlay with a transparent canvas for your high speed animation. 

{#billiards-simulation}
## Billiards simulation with MobX and canvas

![Billiards game](images/es6v2/billiards-start.png)

We're building a small game. You have 11 glass balls – marbles, if you will. Grab one, throw it at the others, see how they bounce around. There is no point to the game, but it looks cool and it's fun to build.

We're using React and Konva to render our 11 marbles on an HTML5 Canvas element, MobX to drive the animation loop, and D3 to help with collision detection. Because of our declarative approach to animation, we can split this example into two parts:

1. Part 1: Rendering the marbles
2. Part 2: Building the physics

You can see the finished [code on Github](https://github.com/Swizec/declarative-canvas-react-konva) and play around with a [hosted version](https://swizec.github.io/declarative-canvas-react-konva/) of the code you're about to build. 

I know this example comes late in the book and you're feeling like you know all there is to React and visualizations. You can think of this example as practice. And it's a good way to learn the basics of MobX.

### Decorators

Before we begin, let me tell you about decorators. MobX embraces them to make its API easier to use. You can use MobX without decorators, but decorators make it better. I promise.

About two years ago decorators got very close to becoming an official spec, then were held back. I don't know *why*, but they're a great feature whose syntax is unlikely to change. So even if MobX has to change its implementation when decorators do land in the spec, you're not likely to have to change anything.

You can think of decorators as function wrappers. Instead of something like this:

{caption: "Decoratorless function wrapping"}
```javascript
inject('store', ({ store }) => <div>A thing with {store.value}</div>);
```

You can write something like this:

{caption: "Function wrapping with decorators"}
```javascript
@inject('store')
({ store }) => <div>A thing with {store.value}</div>
```

I know, that's not much of a difference. It becomes better looking when you work with classes or combine multiple decorators. That's when they shine. No more `})))}))` at the end of your function declarations.

By the way, `inject` is to MobX much like `connect` is to Redux. We'll talk more about that later.

### Part 0: Some setup

Because decorators aren't in the JavaScript spec, we have to tweak how we start our project. We can still use `create-react-app`, but there's an additional step.

You should start a new project like this:

{caption: "Create the billiards game project"}
```
$ create-react-app billiards-game --scripts-version custom-react-scripts
```

This command creates a new directory with a full setup for React. Just like you're used to.

The addition of `--scripts-version custom-react-scripts` employs @kitze's [custom-react-scripts](https://github.com/kitze/custom-react-scripts) project to give us more configuration options. Namely the ability to enable decorators.

We enable them in the `.env` file. Add this line:

{caption: "Add to .env settings"}
```
// billiards-game/.env
// ...
REACT_APP_DECORATORS=true
```

No installation necessary. I think `custom-react-scripts` uses the `transform-decorators-legacy` Babel plugin behind the scenes. It's pre-installed, and we just enabled it with that `.env` change.

Before we begin, you should install the other dependencies as well:

{caption: "Install libraries"}
```
$ npm install --save konva react-konva mobx mobx-react d3-timer d3-scale d3-quadtree
```

This installs Konva, MobX, and the parts of D3 that we need. You're now ready to build the billiards game.

### A quick MobX primer

Explaining MobX in detail is beyond the scope of this book. I bet you can learn it by osmosis as you follow the code in our billiards example. 

That said, here's a quick rundown of the concepts we're using.

MobX implements the ideas of reactive programming. There are values that are observable and functions that react when those values change. MobX ensures only the minimal possible set of observers is triggered on every change.

So, we have:

`@observable` – a property whose changes observers subscribe to
`@observer` – a component whose `render()` method observes values
`@computed` – a method whose value can be fully derived from obsevables
`@action` – a method that changes state, analogous to a Redux reducer
`@inject` – a decorator that injects global stores into a component's props

That's basically all you need to know. Once your component is an `@observer`, you never have to worry about *what* it's observing. MobX ensures it reacts only to the values that it uses during rendering.

Making your component an observer and injecting the global store, is the same as using `connect` in Redux. It gives your component access to your stare, and it triggers a re-render when something that the component uses changes.

Most importantly, it *doesn't* trigger a re-render when something that the component isn't using changes. That little niggle is what makes most other reactive libraries difficult to use.

### Part 1: Rendering our marbles

Our marbles render on canvas using Konva. Each marble is its own  sprite rendered as a Konva element. This makes it easier to implement user and marble interactions.

Rendering happens in 3 components:

- `App` holds everything together
- `MarbleList` renders a list of marbles
- `Marble` renders an individual marble

We're also using 2 MobX stores:

- `Sprite` to load the marble sprite and define coordinates within
- `Physics` as our physics engine

`Sprite` and `Physics` are going to hold almost all of our game logic. We're putting a bit of drag&drop logic in the `Marble` component, but other than that, all our components are presentational. They get props and render stuff.

Let's start with `App` and work our way down.

#### App

Our `App` component doesn't do much. It imports our MobX stores,  triggers sprite loading, and starts the game loop.

{caption: "The App component"}
```javascript
// src/components/App.js

import React, { Component } from 'react';
import { Provider as MobXProvider, observer } from 'mobx-react';

import Physics from '../logic/Physics';
import Sprite from '../logic/Sprite';
import MarbleList from './MarbleList';

@observer
class App extends Component {
    componentWillMount() {
        Sprite.loadSprite(() => Physics.startGameLoop());
    }

    render() {
        return (
            <div className="App">
                <div className="App-header">
                    <h2>Elastic collisions</h2>
                    <p>Rendered on canvas, built with React and Konva</p>
                </div>
                <div className="App-intro">
                    <MobXProvider physics={Physics} sprite={Sprite}>
                        <MarbleList />
                    </MobXProvider>
                </div>
            </div>
        );
    }
}

export default App;
```

We import our dependencies: React itself, a `MobXProvider` which is similar to the Redux provider (it puts stuff in react context), both our MobX stores which export singleton instances, and the main `MarbleList` component. 

`App` itself is a full featured component that initiates sprite loading in `componentDidMount` and calls `startGameLoop` when the sprite is ready. We know the sprite is ready because it calls a callback. You'll see how that works in a bit.

The `render` method outputs some descriptive text, and the `MarbleList` component wrapped in a `MobXProvider`. The provider puts instances of our stores – `sprite` and `physics` – in React context.
  
This makes them available to all child components via the `inject` decorator.

#### MarbleList

Even though `MarbleList` is an important component that basically renders the whole game, it can be a functional stateless component. All the props it needs come from the two stores.

Like this:

{caption: "MarbleList component"}
```javascript
// src/components/MarbleList.js

import React from 'react';
import { inject, observer } from 'mobx-react';
import { Stage, Layer, Group } from 'react-konva';

import Marble from './Marble';

const MarbleList = inject('physics', 'sprite')(observer(({ physics, sprite }) => {
    const { width, height, marbles } = physics;
    const { marbleTypes } = sprite;

    return (
        <Stage width={width} height={height}>
            <Layer>
                <Group>
                    {marbles.map(({ x, y, id }, i) => (
                        <Marble x={x}
                                y={y}
                                type={marbleTypes[i%marbleTypes.length]}
                                draggable="true"
                                id={id}
                                key={`marble-${id}`} />
                    ))}
                </Group>
            </Layer>
        </Stage>
    );
}));

export default MarbleList;
```

We import our dependencies and create a `MarbleList` component. Instead of decorators, we're going with functional composition. 

This shows you that MobX *can* work without decorators, but there's no real reason behind this choice. Over time I've developed a preference to use composition for functional stateless components and decorators for class-based components.

`inject` takes values out of context and puts them in component props. `observer` declares that our component observes those props and reacts to them.

It's generally a good idea to use both `inject` and `observer` together. I have yet to find a case where you need just one or the other.

The rendering itself, takes values out of our stores, and returns a Konva `Stage` with a single `Layer`, which contains a `Group`. Inside this group is our list of marbles. 

Each marble gets a position, a `type` that defines how it looks, an `id`, and a `key`. We set `draggable` to `true` so Konva knows that this element is draggable.

Yes, that means we get draggability on an HTML5 Canvas without any extra effort. I like that.

#### Marble

Each `Marble` component renders a single marble and handles dragging and dropping. We could, perhaps should, have put this logic in the physics store, but I felt this makes more sense.

The component looks like this:

{caption: "Marble component"}
```javascript
// src/components/Marble.js

import React, { Component } from 'react';
import { Circle } from 'react-konva';
import { inject, observer } from 'mobx-react';

@inject('physics', 'sprite') @observer
class Marble extends Component {
    onDragStart() {
        // set drag starting position
    }

    onDragMove() {
        // update marble position
    }

    onDragEnd() {
        // shoot the marble
    }

    render() {
        const { sprite, type, draggable, id, physics } = this.props;
        const MarbleDefinitions = sprite.marbleDefinitions;
        const { x, y, r } = physics.marbles[id];

        return (
            <Circle x={x} y={y} radius={r}
                    fillPatternImage={sprite.sprite}
                    fillPatternOffset={MarbleDefinitions[type]}
                    fillPatternScale={{ x: r*2/111, y: r*2/111 }}
                    shadowColor={MarbleDefinitions[type].c}
                    shadowBlur="15"
                    shadowOpacity="1"
                    draggable={draggable}
                    onDragStart={this.onDragStart.bind(this)}
                    onDragEnd={this.onDragEnd.bind(this)}
                    onDragMove={this.onDragMove.bind(this)}
                    ref="circle"
                    />
        );
    }
}

export default Marble;
```

We `@inject` both stores into our component and make it an `
`@observer`. The `render` method takes values out of our stores and renders a Konva `Circle`. The circle uses a chunk of our sprite as its background, has a colorful shadow, and a bunch of drag callbacks.

Those callbacks make our game playable.

In `onDragStart` we store the starting position of the marble being dragged. In `onDragMove` we update the marble's position in the store, which makes it possible for other marbles to bounce off ours while it's moving, and in `onDragEnd` we shoot the marble.

Shoot direction depends on how we dragged. That's why we need to store the starting positions.

Our drag callbacks double as MobX actions, which makes our code simpler. Instead of specifying an extra `@action` in the MobX store, we manipulate the values directly.

MobX makes this okay. It keeps everything in sync and our state easy to understand. MobX even batches several value changes together before triggering re-renders.

That said, I would recommend using explicit `@actions` in larger projects. 

Here's what the dragging callbacks look like.

{caption: "Dragging callbacks"}
```javascript
// src/components/Marble.js

class Marble extends Component {
    onDragStart() {
        const { physics, id } = this.props;

        this.setState({
            origX: physics.marbles[id].x,
            origY: physics.marbles[id].y,
            startTime: new Date()
        });
    }

    onDragMove() {
        const { physics, id } = this.props;
        const { x, y } = this.refs.circle.attrs;

        physics.marbles[id].x = x;
        physics.marbles[id].y = y;
    }

    onDragEnd() {
        const { physics } = this.props,
              circle = this.refs.circle,
              { origX, origY } = this.state,
              { x, y } = circle.attrs;


        const delta_t = new Date() - this.state.startTime,
              dist = (x - origX) ** 2 + (y - origY) ** 2,
              v = Math.sqrt(dist)/(delta_t/16); // distance per frame (= 16ms)

        physics.shoot({
           x: x,
           y: y,
           vx: (x - origX)/(v/3), // /3 is a speedup factor
           vy: (y - origY)/(v/3)
           }, this.props.id);
    }
    
    // ...
}
```

In `onDragStart` we store original coordinates and start time in local state. These are temporary values that nobody outside this user action cares about. Local state makes sense.

We'll use them to determine how far the user dragged our marble.

In `onDragMove` we update the MobX stare with new coordinates for this particular marble. You might think we're messing with mutable state here, and we *might* be, but these are MobX observables. They're wrapped in setters that ensure everything is kept in sync, changes are being logged, etc.

I don't know how MobX keeps track behind the scenes. I just know it's okay to "change" values.

`onDragEnd` is where the marble shooting happens. We calculate drag speed and direction, and call the `shoot()` action on the `physics` store.

If you're not sure how our math works, I suggest looking up [euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance).

#### Sprite store

Now that we know how rendering works, we ned to load our sprite. It's an icon set I bought somewhere online, but can't remember where or who from.

Here's what it looks like:

![Marbles sprite](images/es6v2/monster-marbles-sprite-sheets.jpg)

To use this we need two things:

1. A way to tell where on the image each marble lies
2. A MobX store that loads the image into memory

The first is a `MarbleDefinitions` dictionary. We used it in `Marble` component's render method.

{caption: "MarbleDefinitions dictionary"}
```javascript
// src/logic/Sprite.js

const MarbleDefinitions = {
    dino: { x: -222, y: -177, c: '#8664d5' },
    redHeart: { x: -222, y: -299, c: '#e47178' },
    sun: { x: -222, y: -420, c: '#5c96ac' },

    yellowHeart: { x: -400, y: -177, c: '#c8b405' },
    mouse: { x: -400, y: -299, c: '#7d7e82' },
    pumpkin: { x: -400, y: -420, c: '#fa9801' },

    frog: { x: -576, y: -177, c: '#98b42b' },
    moon: { x: -575, y: -299, c: '#b20717' },
    bear: { x: -576, y: -421, c: '#a88534' }
};

export { MarbleDefinitions };
```

Each type of marble has a name, a coordinate, and a color. The coordinate tells us where on the sprite image it is, and the color helps us define a nice looking shadow.

All values were painstakingly assembled by hand. You're welcome.

The MobX store that loads our sprite into memory and helps us use it looks like this:

{caption: "Sprite store"}
```javascript
// src/logic/Sprite.js

import { observable, action, computed } from 'mobx';
import MarbleSprite from '../monster-marbles-sprite-sheets.jpg';

class Sprite {
    @observable sprite = null;

    @action loadSprite(callback = () => null) {
        const sprite = new Image();
        sprite.src = MarbleSprite;

        sprite.onload = () => {
            this.sprite = sprite;

            callback();
        };
    }

    @computed get marbleTypes() {
        return Object.keys(MarbleDefinitions);
    }

    @computed get marbleDefinitions() {
        return MarbleDefinitions;
    }
}

export default new Sprite();
```

As you can see a MobX store is a JavaScript object. It has `@observable` values, `@actions` and `@computed` getters. There's nothing more to it than that.

No complicated reducers and action generators, just JavaScript functions and properties. There's plenty going on behind the scenes, but we don't have to think about it.
  
That's why I personally like MobX more than Redux. Feels easier to use :)

In the `Sprite` store we have an `@observable sprite`. Changing this value will trigger a re-render in our `@observer` components that rely on it. Every marble in our case.

Then we have a `loadSprite` action, which creates a new `Image` object and loads the sprite. When the image is done loading, we set `this.sprite`.

Our `@computed` getters make it easier to access `MarbleDefinitions`. `marbleTypes` gives us a list of available types of marbles and `marbleDefinitions` returns the definitions object.

Running your code won't work just yet. We need the physics store first because it defines marble positions.

### Part 2: Building the physics

Our whole physics engine fits into a single MobX store. It contains the collision detection, marble movement calculations, and drives the game loop itself.

The general approach goes like this:

1. Have an observable array of marbles
2. Run a `simulationStep` on each `requesAnimationFrame` using `d3.timer`
3. Change marble positions and speed
4. MobX observables and observers trigger re-renders of marbles that move

The [whole Physics store](https://github.com/Swizec/declarative-canvas-react-konva/blob/master/src/logic/Physics.js) is some 120 lines of code so I won't share it all at once. Here's what its skeleton looks like:

{caption: "Physics skeleton"}
```javascript
// src/logic/Physics.js

class Physics {
    @observable MarbleR = 25;
    @observable width = 800;
    @observable height = 600;
    @observable marbles = [];
    timer = null;
    
    @computed get initialPositions() {
 
    }

    @action startGameLoop() {
  
    }

    @action simulationStep() {
  
    }

    @action shoot({ x, y, vx, vy }, i) {
  
    }
}
```

We have four observable properties, a `timer`, a `@computed` property for initial positions, and 3 actions. The `startGameLoop` starts our game, `simulationStep` holds our main logic, and `shoot` shoots a particular marble.

Let's walk through.

#### initialPositions

{caption: "initialPositions function"}
```javascript
// src/logic/Physics.js
class Physics {
		// ..
    @computed get initialPositions() {
        const { width, height, MarbleR } = this,
              center = width/2;

        const lines = 4,
              maxY = 200;

        let marbles = range(lines, 0, -1).map(y => {
            if (y === lines) return [{ x: center, y: maxY,
                                       vx: 0, vy: 0, r: this.MarbleR}];

            const left = center - y*(MarbleR+5),
                  right = center + y*(MarbleR+5);

            return range(left, right, MarbleR*2+5).map(x => ({
                x: x,
                y: maxY-y*(MarbleR*2+5),
                vx: 0,
                vy: 0,
                r: this.MarbleR
            }));
        }).reduce((acc, pos) => acc.concat(pos), []);

        marbles = [].concat(marbles, {
            x: width/2,
            y: height-150,
            vx: 0,
            vy: 0,
            r: this.MarbleR
        });

        marbles.forEach((m, i) => marbles[i].id = i);

        return marbles;
    }
    // ..
}
```

Believe it or not, this is like one of those *"Arrange things in a triangle"* puzzles you'd see in an old Learn How To Program book. Or a whiteboard interview.

It took me 3 hours to build. Super easy to get wrong and very fiddly to implement.

We start with a `range` of numbers. From `lines` to `0` in descending order. We iterate through this list of rows and change each into a list of marbles.

4 marbles in the first row, 3 in the next, all the way down to 1 in last row. 

For each row, we calculate how much space we have on the `left` and `right` of the center, make a `range` of horizontal positions from `left` to `right` with a step of "1 marble size".  Using these positions and the known row we create marbles as needed.

We use a `.reduce` to flatten nested arrays, and add the last marble. That's a corner case I couldn't solve elegantly, but I'm sure it's possible.

In the end we add an `id` to each marble. We're using index as the id, that's true, but that still ensures we use consistent values throughout our app. Positions in the array may change.

#### shoot and startGameLoop

{caption: "shoot and startGameLoop functions"}
```javascript
// src/logic/Physics.js
class Physics {
    // ...
    
    @action startGameLoop() {
        this.marbles = this.initialPositions;

        this.timer = timer(() => this.simulationStep());
    }
    
    // ...
    
    @action shoot({ x, y, vx, vy }, i) {
        const maxSpeed = 20;

        this.marbles[i].x = x;
        this.marbles[i].y = y;
        this.marbles[i].vx = vx < maxSpeed ? vx : maxSpeed;
        this.marbles[i].vy = vy < maxSpeed ? vy : maxSpeed;
    }
}
```

`shoot` and `startGameLoop` are the simplest functions in our physics engine. `startGameLoop` creates the initial `marbles` array, and `shoot` updates a specific marble's coordinates and speed vector.

Lovely :)

#### simulationStep – where collisions collision

Here comes the fun part. The one with our game loop.

I've also made a video of all this. [Watch it on YouTube](https://www.youtube.com/watch?v=H84fmXjTElM). It involves hand-drawn sketches that explain the math and I think that's neat.

{caption: "Full simulationStep function"}
```javascript

@action simulationStep() {
    const { width, height, MarbleR } = this;

    const moveMarble = ({x, y, vx, vy, id}) => {
        let _vx = ((x+vx < MarbleR) ? -vx : (x+vx > width-MarbleR) ? -vx : vx)*.99,
            _vy = ((y+vy < MarbleR) ? -vy : (y+vy > height-MarbleR) ? -vy : vy)*.99;

        // nearest marble is a collision candidate
        const subdividedSpace = quadtree().extent([[-1, -1],
                                                   [this.width+1, this.height+1]])
                                          .x(d => d.x)
                                          .y(d => d.y)
                                          .addAll(this.marbles
                                                      .filter(m => id !== m.id)),
              candidate = subdividedSpace.find(x, y, MarbleR*2);

        if (candidate) {

            // borrowing @air_hadoken's implementation from here:
            // https://github.com/airhadoken/game_of_circles/blob/master/circles.js#L64
            const cx = candidate.x,
                  cy = candidate.y,
                  normx = cx - x,
                  normy = cy - y,
                  dist = (normx ** 2 + normy ** 2),
                  c = (_vx * normx + _vy * normy) / dist * 2.3;

            _vx = (_vx - c * normx)/2.3;
            _vy = (_vy - c * normy)/2.3;

            candidate.vx += -_vx;
            candidate.vy += -_vy;
            candidate.x += -_vx;
            candidate.y += -_vy;
        }

        return {
            x: x + _vx,
            y: y + _vy,
            vx: _vx,
            vy: _vy
        }
    };

    this.marbles.forEach((marble, i) => {
        const { x, y, vx, vy } = moveMarble(marble);

        this.marbles[i].x = x;
        this.marbles[i].y = y;
        this.marbles[i].vx = vx;
        this.marbles[i].vy = vy;
    });
}
```

That's a lot of code 😅. Let's break it down. 

You can think of `simulationStep` as a function and a loop. At the bottom, there is a `.forEach` that applies a `moveMarble` function to each marble.

{caption: "Loop through marbles"}
```javascript
    this.marbles.forEach((marble, i) => {
        const { x, y, vx, vy } = moveMarble(marble);

        this.marbles[i].x = x;
        this.marbles[i].y = y;
        this.marbles[i].vx = vx;
        this.marbles[i].vy = vy;
    });
```

We iterate over the list of marbles, feed them into `moveMarble`, get new properties, and save them in the main marbles array. This might be unnecessary because of MobX. We *should* be able to change them inside the loop and rely on MobX observables to do the heavy lifting.

I wonder why I did it like this 🤔 Maybe a leftover from before MobX ...

##### moveMarble

`moveMarble` is itself a hairy function. Things happen in 3 steps:

1. Handle collisions with walls
2. Find collision with closest other marble
3. Handle collision with marble

**Handling collisions with walls happens** in two lines of code. One per coordinate.

```javascript
let _vx = ((x+vx < MarbleR) ? -vx : (x+vx > width-MarbleR) ? -vx : vx)*.99,
    _vy = ((y+vy < MarbleR) ? -vy : (y+vy > height-MarbleR) ? -vy : vy)*.99;
```

Nested ternary expressions are kinda messy, but good enough. If marble is beyond any boundary, we reverse its direction. We *always* apply a `.99` friction coefficient so that marbles slow down.

**Finding collisions** with the next closest marble happens via a quadtree. Since we don't have too many marbles, we can afford to build a new quadtree from scratch every time.

{aside}
A quadtree is a good way to subdivide space into areas. It lets us answer the question of "What's close enough to me to possibly touch me?" without making too many position comparisons.

Checking every marble with every other marble produces 81 comparisons. Versus 2 comparisons using a quadtree.
{/aside}

```javascript
// nearest marble is a collision candidate
const subdividedSpace = quadtree().extent([[-1, -1],
                                           [this.width+1, this.height+1]])
                                  .x(d => d.x)
                                  .y(d => d.y)
                                  .addAll(this.marbles
                                              .filter(m => id !== m.id)),
      candidate = subdividedSpace.find(x, y, MarbleR*2);
```

We're using [`d3-quadtree`](https://github.com/d3/d3-quadtree) for the quadtree implementation. It takes an `extent`, which tells it how big our space is. It uses `x` and `y` accessors to get coordinates out of our marble objects, and we use `addAll` to fill it with marbles.

To avoid detecting each marble as colliding with itself, we take each marble out of our list before feeding the quadtree. 

Once we have a quadtree built out, we use `.find` to look for the nearest marble within `MarbleR*2` of the current marble. Which is exactly the one we're colliding with! :)

**Handling collisions with marbles** involves math. The sort of thing you think you remember from high school, and suddenly realize you don't when the time comes to use it.

The code looks like this:

```javascript
if (candidate) {

    // borrowing @air_hadoken's implementation from here:
    // https://github.com/airhadoken/game_of_circles/blob/master/circles.js#L64
    const cx = candidate.x,
          cy = candidate.y,
          normx = cx - x,
          normy = cy - y,
          dist = (normx ** 2 + normy ** 2),
          c = (_vx * normx + _vy * normy) / dist * 2.3;

    _vx = (_vx - c * normx)/2.3;
    _vy = (_vy - c * normy)/2.3;

    candidate.vx += -_vx;
    candidate.vy += -_vy;
    candidate.x += -_vx;
    candidate.y += -_vy;
}

return {
    x: x + _vx,
    y: y + _vy,
    vx: _vx,
    vy: _vy
}
```

Ok, the `return` statement isn't about handling collisions. It updates the current marble.

The rest kind of looks like magic. I implemented it and it looks like magic and I feel like I don't *really* understand it.

You can think of `[normx, normy]` as a vector that points from current marble, to collision candidate. It gives us bounce direction. We use the [euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance) formula to calculate the length of this vector. The distance between the centers of both marbles.

Then we calculate the [dot product](https://en.wikipedia.org/wiki/Dot_product) between our marble's speed vector, and the collision direction vector. And we normalize it by distance. Multiplying distance by `2` accounts for there being two marbles in the collision. That extra `.3` made the simulation look better.

I fiddled with it :)

Then we use the dot product scalar to adjust the marble's speed vector. Dividing by `2` takes into account that half the energy goes to the other marble. This is only true because we assume their masses are equal.

Finally we update the `candidate` marble and make sure it bounces off as well. We do it additively because that's how it happens in real life.

Now two marbles traveling towards each other in exactly opposite directions with exactly the same speed, will stop dead and stay there. As soon as there's any misalignment, deflection happens. If one is stationary, it starts moving. If it's moving in the same direction, it speeds up ... etc.

The end result is [a decent-looking simulation of billiards](https://swizec.github.io/declarative-canvas-react-konva/). I'd show you a gif, but those don't work well in books.

# Reducing the amount of computation

# Switching to Preact or Inferno
