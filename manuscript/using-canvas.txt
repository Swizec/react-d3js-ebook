# Speed optimizations #

Welcome to the section on speed optimizations. This is where we make our code harder to read and faster to run.

You might never need any of the techniques discussed here. You already know how to build performant data visualization components. For 99% of applications, plain code that's easy to read and understand is plenty fast.

Do you really need to save that tenth of a second at runtime and spend an extra hour thinking every time there's a bug?

Answer honestly.

That said, there are cases where faster code is also easier to read. And there are cases where your visualization is so massive, that you need every ounce of oomph you can get.

For the most part, we're going to talk about three things:

- using canvas to speed up rendering
- using React-like libraries to speed up the core library
- avoiding unnecessary computation and redraws

We'll start with canvas because it's the biggest speed improvement you can make.

# Using canvas

We've been using SVG to render our apps so far. SVG is great because it follows a familiar structure, offers infinitely scalable vector graphics, and works pretty much everywhere. Sure you can't use some fancy SVG features on all browsers, but the basics are solid.

However, SVG has a big flaw: it's slow.

Anything more than a few hundred SVG nodes and your browser will struggle. Especially if you want to animate those thousands of elements.

A panelist at ForwardJS once asked me *"But why would you want that?"*. It was my first time participating in a panel and my answer sucked. Here's the real answer: *"Because there have been thousands of UFO sightings, there are thousands of counties in the US, millions of taxi rides, hundreds of millions of people having this or that datapoint. And you want to show change over time"*

That's the real answer. Sometimes, when you're visualizing some data, you have a lot of data. The data changes over time, and animation is the best way to show changes over time.

Once upon a time I was working on a [D3 video course](TODO:masteringd3jslink) for Packt and used UFO sightings as an example. At peak UFO sighting, right before smartphones become a thing, the animation takes up to 2 seconds to redraw a single frame. 

It's terrible.

So if SVG is slow and you need to animate thousands of elements, what are you to do? HTML5 Canvas.

## Why canvas

Unlike SVG, HTML5 Canvas lets you draw rasterized images. This means you're not longer operating at the level of shapes, you're working with pixels on the screen.

With SVG, you tell the browser *what* you want to render. With canvas, you tell the browser *how* you want to render. The browser doesn't know what you're doing, it just gets a field of pixel colors and renders them as an image.

As a result, browsers can use the GPU to render canvas. With a bit of care, you can do almost anything you want even on a mobile phone.

Phones these days have amazing GPUs and kind of terrible CPUs. That's why I'd almost suggest going straight to canvas for any sort of complex animation. Mobile traffic is, what, 60% or even 70% of traffic these days?

Now you might be thinking this sounds complicated. How do you know which pixel should do what when you're rendering with canvas? Sounds like a lot of work.

HTML5 Canvas does offer some shape primitives. It has circles and rectangles and things like that, but they suffer from the same problem that SVG does. The browser has to use your CPU to calculate those and at around 10,000 elements things break down.

Notice that 10,000 elements is still a hell of a lot more than the 3,000 or so that SVG gives you.

If your app allows it, you can use sprites. Tiny images copy pasted on the canvas as bytestreams. I have yet to find an upper bound for those. My JavaScript became the bottleneck :D

But I'm getting ahead of myself, we'll talk about sprites later.

## The trouble with HTML5 Canvas

A tricky thing with HTML5 Canvas is that the API is low level and that canvas is flat. As far as your JavaScript and React code are concerned, it's a flat image. Could be anything.

There's no structure, which makes it difficult to detect clicks on elements, interactions between elements, when something covers something else, how the user interacts with your stuff and things like that. You have to move most of that logic into your data store and manually keep track.

You can imagine this becomes cumbersome. And you still can't detect user interaction because all you get is *"User clicked on  coordinate (x, y). Have fun"*.

At the same time, the low level API makes abstractions difficult. You can't create components for "this is a map" or "histogram goes here". You're always down to circles and rectangles and basic shapes at best.

Your code can soon start looking much like the D3.js spaghetti we wanted to avoid in the first place.

## Declarative HTML5 Canvas with Konva and react-konva

Enter [Konva](https://konvajs.github.io) and react-konva. All the benefits of declarative code, but rendered on the canvas.

I'm gonna let Anton Lavrenov, the author of Konva, explain:

> Konva is an HTML5 Canvas JavaScript framework that enables high performance animations, transitions, node nesting, layering, filtering, caching, event handling for desktop and mobile applications, and much more.

> You can draw things onto the stage, add event listeners to them, move them, scale them, and rotate them independently from other shapes to support high performance animations, even if your application uses thousands of shapes. Served hot with a side of awesomeness.

That. 

It's exactly what we need to push our animated React apps to thousands of elements. Without spending too much time thinking about the *how* of rendering. Best leave the hairy details to somebody else.

Let me show you two examples.

1. Pushing our particle generator to 20,000 elements
2. An n-body collision simulator built with MobX

{#canvas-react-redux}
## A particle generator pushed to 20,000 elements with canvas

Our [SVG-based particle generator](#animating-react-redux) caps out at a few thousand elements. Animation becomes slow and time between each iteration of our game loop increases.

Old elements leave the screen and get pruned faster than we can create new ones. This creates a natural (but stochastic) upper limit to how many elements we can push into the page.

We can render many more elements, if we take out SVG and use HTML5 Canvas instead. I was able to push the code up to around 20,000 smoothly animated elements. Then JavaScript became the bottleneck.

You can see it in action hosted on [Github pages](http://swizec.github.io/react-particles-experiment/).

We're going to keep most of our code from before. The only changes happen in `src/components/index.jsx` where a Konva stage replaces the `<svg>` element, and in `src/components/Particles.jsx` where we change what we render.

You should go into your particle generator directory, install  Konva and react-konva, then make the changes below. Trying things out is better than just reading my code ;)

```
$ npm install --save konva react-konva
```

{aside}
react-konva is a thin wrapper on Konva itself. There's no need to think about it as its own thing. For the most part, you can go into the Konva docs, read about something, and it Just Works in react-konva.
{/aside}

### Preparing a canvas layer

Our changes start in `src/components/index.jsx`. We have to throw away the `<svg>` element and replace it with a Konva stage.

You can think of a Konva stage as a canvas element with a bunch of helper methods attached. Some of them Konva uses internally, others are exposed as an API. Functions like exporting to an image file, detecting intersections, etc.

{caption: "Import Konva and set the stage"}
```javascript
// src/components/index.js

// ...
import { Stage } from 'react-konva';

// ...
class App extends Component {
    // ..
    render() {
        return (
            // ..
                     <Stage width={this.props.svgWidth} height={this.props.svgHeight}>
                         <Particles particles={this.props.particles} />

                     </Stage>

                 </div>
                 <Footer N={this.props.particles.length} />
             </div>
        );
    }
}
```

We import `Stage` from `react-konva`, then use it instead of the `<svg>` element in the `render` method. It gets a `width` and a `height`.

Inside, we render the `Particles` component. It's going to create a Konva Layer and use low-level canvas methods to render particles as sprites.

### Using sprites for max redraw speed

Our [SVG-based Particles](#svg-particles) component was simple. Iterate through a list of particles, render a `<Particle>` component for each.

We're going to completely rewrite it.

Our new approach goes like this:

0. Cache a sprite on `componentDidMount`
1. Clear canvas
2. Redraw all particles
3. Repeat

Because the new approach renders a flat image and because we don't care about interaction with individual particles, we can get rid of the `Particle` component. The unnecessary layer of nesting was slowing us down.

The new `Particles` component looks like this:

{caption: "Sprite-based Particles component"}
```javascript
import React, { Component } from 'react';
import { FastLayer } from 'react-konva';

class Particles extends Component {
    componentDidMount() {
        this.canvas = this.refs.layer.canvas._canvas;
        this.context = this.canvas.getContext('2d');

        this.sprite = new Image();
        this.sprite.src = 'http://i.imgur.com/m5l6lhr.png';
    }

    drawParticle(particle) {
        let { x, y } = particle;

        this.context.drawImage(this.sprite, 0, 0, 128, 128, x, y, 15, 15);
    }

    componentDidUpdate() {
        let particles = this.props.particles;

        console.time('drawing');
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (let i = 0; i < particles.length; i++) {
            this.drawParticle(particles[i]);
        }
        console.timeEnd('drawing');
    }

    render() {
        return (
            <FastLayer ref="layer" transformsEnabled="position" listening="false">

            </FastLayer>
        );
    }
}

export default Particles;
```

40 lines of code is a lot to look at all at once. Let's walk through it step by step.

##### componentDidMount

{caption: "componentDidMount code"}
```javascript
componentDidMount() {
    this.canvas = this.refs.layer.canvas._canvas;
    this.context = this.canvas.getContext('2d');

    this.sprite = new Image();
    this.sprite.src = 'http://i.imgur.com/m5l6lhr.png';
}
```

This is a lifecycle hook that React calls when our component first renders. We use it to set up 3 instance properties.

`this.canvas` is a reference to the HTML5 Canvas element. We get it via a ref to the Konva layer, then spelunk through properties to get the canvas itself. As you can see by the `_` prefix, Anton Lavrenov did not intend this to be a public API.

Thanks to JavaScript's permissiveness we can use it anyway.

`this.context` is a reference to our canvas's CanvasRenderingContext2D. It's the interface we use to draw basic shapes, perform transformations, etc. Context is basically the only part of canvas you ever interact with as a developer.

Why it can't be just canvas, I don't know. 

`this.sprite` is a cached image. A small minion that we are going to copy paste all over the place as our particle. Using a combination of `new Image()` and setting the `src` property, loads it into memory as an HTML5 Image object.

It looks like this:

![Our minion particle](http://i.imgur.com/m5l6lhr.png)

You might be thinking that it's unsafe to copy references to rendered elements into component properties like that, but it's okay. Our render function always renders the same thing, so the reference never changes. Copying them like this means less typing.

##### drawParticle

{caption: "drawParticle code"}
```javascript
drawParticle(particle) {
    let { x, y } = particle;

    this.context.drawImage(this.sprite, 0, 0, 128, 128, x, y, 15, 15);
}
```

This function draws a single particle on the canvas. It gets coordinates from the `particle` and uses `drawImage` to copy our sprite into position.

We use the whole sprite, corner `(0, 0)` to corner `(128, 128)`. That's how big our sprite is by the way. And we copy it to position `(x, y)` with a width and height of `15` pixels.

`drawImage` is the fastest method I've found to put pixels on canvas. I don't know why it's so fast, but here's a [helpful benchmark](https://jsperf.com/canvas-drawimage-vs-putimagedata/3) so you can see for yourself.

##### componentDidUpdate

{caption: "componentDidUpdate code"}
```javascript
componentDidUpdate() {
    let particles = this.props.particles;

    console.time('drawing');
    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);

    for (let i = 0; i < particles.length; i++) {
        this.drawParticle(particles[i]);
    }
    console.timeEnd('drawing');
}
```

##### render

{caption: "render code"}
```javascript
render() {
    return (
        <FastLayer ref="layer" transformsEnabled="position" listening="false">

        </FastLayer>
    );
}
```

------

Chapter coming in January 2017.

Until then, you can read these posts and watch the attached videos:

- [Rendering React components with canvas](https://swizec.com/blog/livecoding-13-rendering-react-components-with-canvas/swizec/6784)
- [Mostly smooth animation up to 4,000 elements with React](https://swizec.com/blog/livecoding-14-mostly-smooth-animation-up-to-4000-elements-with-react-and-canvas/swizec/6864)
- [Reaching the limits of canvas redraw speed](https://swizec.com/blog/livecoding-15-reaching-the-limits-of-canvas-redraw-speed/swizec/6875)
- [canvas.drawImage performance is weird but magical](https://swizec.com/blog/livecoding-16-canvas-drawimage-performance-is-weird-but-magical/swizec/6881)
- [Particle physics is hard](https://swizec.com/blog/livecoding-17-particle-physics-is-hard/swizec/6903)
- [Animating 2048 SVG nodes in React, Preact, Inferno, Vue, Angular 2, and CycleJS – a side-by-side comparison](https://swizec.com/blog/animating-svg-nodes-react-preact-inferno-vue/swizec/7311)

## Reducing the amount of computation

## Switching to Preact or Inferno
