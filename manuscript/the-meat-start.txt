{#the-meat-start}
# Visualizing data with React and d3.js

Welcome to the main part of React+d3.js. We're going to talk a little theory, some principles, then get our hands dirty with a few examples. Through this book you're going to build:

- A choropleth map  <-- need to write
- An interactive histogram  <-- pretty much have
- An animated alphabet  <-- already done
- A simple particle generator  <-- done, should add canvas stuff
- A particle generator pushed to 20,000 elements <-- canvas stuff

Looks random, right? Bear with me.

Examples build on each other in complexity. The first teaches you how to make a static data visualization component and shows you an approach to declarative data visualization. The second adds interactivity and components interacting with each other, this teaches you about a simple approach to state management. The third shows you how to use transitions to build simple animations, and the fourth shows you how to do complex animation using a game loop principle.

The fourth example has a fifth example hidden inside where we talk about using canvas with React and pushing the limits. We're going to animate tens of thousands of elements at the same time, it's going to be great.

If you like buzzwords, here are the technologies we're going to use:

1. React 15, D3v4, ES6
2. React 15, D3v4, ES6, (maybe mobx?)
3. React 15, D3v4, ES6
4. React 15, D3v4, ES6, Redux
5. React 15, D3v4, ES6, Konva, canvas, Redux

Don't worry, if you're not comfortable with ES6 syntax yet. By the end of this book you're gonna love it! In the meantime, here's a helpful cheatsheet for you: [es6cheatsheet.com](https://es6cheatsheet.com/). It compares the ES5 way with the ES6 way so you can brush up quickly.

I'm working on a similar cheatsheet for D3v3 -> D3v4. You'll get an email when it's done.

[^ or maybe just get it done?]

----

Before we begin the examples, let's talk about how React and D3 fit together and how we're going to structure our apps. If you prefer to get your hands dirty first and ask questions later, skip this section and jump to examples.

This section is split into four chapters:

- [Basic Approach](#basic-approach)
- [Blackbox Components](#blackbox-components)
- [Full Feature Integration](#full-feature-integration)
- [State Handling Architecture](#state-handling-architecture)

{#basic-approach}
## The basic approach

Our visualizations are going to use SVG - an XML-based image format that lets us describe images in terms of mathematical shapes. For example, the source code of an 800x600 SVG image with a rectangle looks like this:

{title="SVG rectangle", linenos=off, lang=xml}
	<svg width="800" height="600">
		<rect width="100" height="200" x="50" y="20" />
	</svg>

These four lines create an SVG image with a black rectangle at coordinates `(50, 20)` that is 100x200 pixels large. Black fill with no borders is default for all SVG shapes.

SVG is perfect for data visualization on the web because it works in all browsers, renders without blurring or artifacts on all screens, and supports animation and user interaction. You can see examples of interaction and animation later in this book.

But SVG can get slow when you have thousands of elements on screen. We're going to solve that problem by rendering bitmap images with canvas. More on that later.

----

Another nice feature of SVG is that it's just a dialect of XML - nested elements describe structure, attributes describe the details. The same principles that HTML uses.

That makes React's rendering engine particularly suited for SVG.   Our 100x200 rectangle from before, looks like this as a React component:

{title="A simple rectangle in React",linenos=off,lang=jsx}
    const Rectangle = () => (
        <rect width="100" height="200" x="50" y="20" />
    );

To use this rectangle component in a picture, you'd use a component like this:

{title="Rect component in a picture",linenos=off,lang=jsx}
		const Picture = () => (
			<svg width="800" height="600">
				<Rectangle />
			</svg>
		);

You're right, this looks cumbersome. A lot of work for a static rectangle, right? But look closely, even if you know nothing about React and JSX, you can look at that code and see that it's a `Picture` of a `Rectangle`.

Compare that to a pure D3 approach:

{title="A static rectangle in d3.js",linenos=off,lang=js}
    d3.select("svg")
	    .attr("width", 800)
			.attr("height", 600)
      .append("rect")
      .attr("width", 100)
      .attr("height", 200)
      .attr("x", 50)
      .attr("y", 20);

It's elegant, it's declarative, it looks like function call soup. Even rewriting into a more readable form doesn't make it much easier to understand the SVG structure at a glance. Observe:

{title="Static rectangle in cleaner d3.js",linenos=off,lang=js}
		d3.select("svg")
			.attr({width: 800,
						 height: 600})
		  .append("rect")
		  .attr({width: 100,
					   height: 200,
					   x: 50,
					   y: 20})

That doesn't scream *"Rectangle in an SVG"* to me as much as the React example does. You have to take your time and read the code carefully.

Dealing with the DOM is not D3's strong suit. A lot of typing, code that's hard to read, slow when you have thousands of elements, and it's often hard to keep track of which elements you're changing. D3's enter-update-exit cycle is great theory, but I personally never found it easy to use.

If you don't know what I just said, don't worry, we'll cover the enter-update-exit cycle in the animations example.

That said, D3 is unparalleled when it comes to everything but the DOM. It comes with many statistical functions, great support for data manipulation, and a bunch of built-in data visualizations. D3 can calculate anything for us, all we have to do is draw them out.

We're going to follow this approach:

* React owns the DOM
* D3 calculates properties

This way we can leverage React for SVG structure and rendering optimizations, and D3 for all its mathematical and visualization functions.

{#blackbox-components}
## Blackbox Components

{#full-feature-integration}
## Full-feature Integration

{#state-handling-architecture}
## State Handling Architecture

To make our lives easier, we're going to use a flow-down architecture inspired by Flux. All state is stored in one place - the main component - and data flows down via component properties. Changes travel back up the hierarchy via callbacks.

Our approach differs from Flux (and Redux) in that it doesn't need any extra code, which makes it easier to explain. The downside is that our version doesn't scale as well as Flux would.

If you don't know about Flux or Redux, don't worry; the explanations are self-contained. I only mention them here to make your Googling easier and to give you an idea of how this approach compares. I explain Redux in more detail in the [Animating with React, Redux, and d3 chapter](#animating-react-redux).

![The basic architecture](images/architecture.jpg)

The idea is this:

* The Main Component is the repository of truth
* Child components react to user events
* They announce changes using callbacks
* The Main Component updates its truth
* The real changes flow back down the chain to update UI

This might look roundabout, but I promise, it’s awesome. It's better than worrying about parts of the UI going out of date with the rest of the app. I could talk your ear off with debugging horror stories, but I'm nice, so I won't.

![Data flows down](images/architecture_data.jpg)

Having your components rely just on their properties is like having functions that rely just on their arguments. Given the same arguments, they *always* render the same output.

If you want to read about this in more detail, Google "isomorphic JavaScript". You could also search for "referential transparency" and "idempotent functions".

Either way, functional programming for HTML. Yay!

## Structuring your React app

As you can guess from the architecture chapter, we're going to structure our app into components. Deciding what to put into one component and what into another is one of the hardest problems in engineering.

Entire books have been written on the topic, so here's a rule of thumb that I like to use: If you have to use the word "and" to describe what your component does, then it should become two components.

Once you have those two components, you can either make them child components of a bigger component, or you can make them separate. The choice depends on their re-usability.

For instance, to build our H1B histogram visualization, we are going to build two top-level components:

 - H1BGraph, which handles the entire UI
 - Histogram, which is a passive component for rendering labeled histograms

Histogram is going to be a child of H1BGraph in the final hierarchy, but we might use it somewhere else. That makes it a good candidate for a stand-alone component.

Other components such as the mean value dotted line, filter controls, and title/description meta components are specific to this use-case. We'll build them as child components of H1BGraph. Building them as separate components makes them easier to reason about, reusable locally within H1BGraph, and easier to write tests for.

We're not going to write tests here, though. That's a topic for another book. Right now, we’re going to focus on React and d3.js.

Each component will have its own folder inside `src/components/`, or its parent component, and at least an `index.jsx` file. Some will have style definitions, child components, and other JavaScript files as well.

In theory, each component should be accessible with `require('./MyComponent')`, and rendered with `<MyComponent {...params} />`. If a parent component has to know details about the implementation of a child component, something is wrong.

You can read more about these ideas by Googling ["leaky abstractions"](https://en.wikipedia.org/wiki/Leaky_abstraction), ["single responsibility principle"](https://en.wikipedia.org/wiki/Single_responsibility_principle), ["separation of concerns"](https://en.wikipedia.org/wiki/Separation_of_concerns), and ["structured programming"](https://en.wikipedia.org/wiki/Structured_programming). Books from the late 90's and early 2000's (when object oriented programming was The Future (tm)) are the best source of [curated] info in my experience.

## Bootstrap your app into place

Let's start by bootstrapping our app into place. We're going to make a simple `src/index.jsx` file – we set that to be our main entry file in [the environment section](#the-environment) – and an empty `H1BGraph` component that renders an SVG element.

We start by importing `React`, `ReactDOM`, and `H1BGraph`.

{crop-start-line=5,crop-end-line=10,linenos=off,lang=jsx}
<<[Import main dependencies](code_samples/es6/index.jsx)

`React` is, well, React. We need it for just about everything. `ReactDOM` is React's DOM renderer, which is new in v0.14. Rendering got split out of base React so that it's easier to build React apps for different render targets like canvas, WebGL, native mobile, etc. `H1BGraph` is going to be our main component.

We're using ES6-style imports instead of `require()` because it gives us greater flexibility to import only the parts we want and it reads like a normal English sentence in most common-use cases. You'll see this play out in future examples.

The second argument must be a string even if you're importing a library.

The main entry point for the app is also a good place to define any convenience helper functions that should be available globally but aren't big enough or important enough to make a new library for. We'll add `capitalize` and `decapitalize` to the `String` class. There are libraries out there that do this, but there's no need to add an entire string manipulation library to our codebase if all we need are two functions.

{crop-start-line=14,crop-end-line=29,linenos=off,lang=jsx}
<<[Define two string helpers](code_samples/es6/index.jsx)

Now we'll be able to capitalize and decapitalize any string in our codebase with a call like `"some thing".capitalize()`. We're going to use this in the `Title` and `Description` meta components. We define them here because they change the global String class, and it would be odd if that happened deep down in a child component… maybe we should've just avoided changing built-in classes.

All we need now is to render `H1BGraph` into the page.

{crop-start-line=46,crop-end-line=53,linenos=off,lang=jsx}
<<[Render H1BGraph onto page](code_samples/es6/index.jsx)

This tells React to take control of the HTML element with class `h1bgraph` – a `<div>` inside the main container in our case – and render the `H1BGraph` component. We used `ReactDOM.render` because we're rendering for and in a browser. Other renderers exist, but they're not important right now.

You can think of this function call as a *"Give me a Thing That Does Stuff"*. It doesn't have to stand on its own. You could wrap it in a jQuery plugin, use it inside a Backbone or Angular view, or in whatever else you're already used to. That's how you can make a gradual transition towards React that doesn't force you to throw existing code away.

If you've kept `npm start` running in the background, it should now complain that `components/H1BGraph` doesn't exist. Let's fix that and get an empty `<svg>` element rendering.

## Start with a basic component

All of our components are going to start the same way – some imports, a class with a `render()` method, and a default module export. That's the minimum we need in `<component>/index.jsx` to define a component that doesn't break our build.

Right now, the main entry file tries to import and render `H1BGraph`, but it doesn't exist yet. Let's start a new file in `src/components/H1BGraph/index.jsx`.

{crop-start-line=5,crop-end-line=8,linenos=off,lang=jsx}
<<[Basic imports](code_samples/es6/H1BGraph/index.jsx)

We import React and a base `Component` class. We have to import `React` even if we don't use it explicitly because Webpack throws a "React not defined" error otherwise. We'll use the `Component` class to build our own components off of.

We also import `d3` because we'll use it to load data later. 

{crop-start-line=12,crop-end-line=28,linenos=off,lang=jsx}
<<[Empty H1BGraph component](code_samples/es6/H1BGraph/index.jsx)

Then we define a component that renders an empty `<svg>` tag inside a `<div>`. A component must have at least a `render()` function; otherwise, React throws an error when it tries to render. With v0.14 we also got stateless functional components, which are essentially just the `render()` function. They don't feature in this Histogram example, but you can see some in the animation chapter.

We're using ES6's concept of classes and class inheritance to extend React's basic `Component`, which we imported earlier. This is widely accepted as more readable than JavaScript's old/standard prototypical inheritance.

You can still use `React.createClass` if you want. It works just fine and is equivalent to `class X extends Component`.

{crop-start-line=32,crop-end-line=50,linenos=off,lang=jsx}
<<[Export H1BGraph](code_samples/es6/H1BGraph/index.jsx)

In the end, we export `H1BGraph` so other parts of the codebase can import it. We define it as the `default` export because this particular file only exports a single class.

If we had multiple things to export, we'd use named exports. They look like this: `export { Thing }`. You can also define the Thing anonymously when exporting, like this: `export function Thing () { // ... }`.

Using default exports makes our components easier to import - `import Thing from 'file'`. To import named exports, you have to specify them inside curly braces: `import { Thing1, Thing2 } from 'file'`.

Hot reloading and continuous compilation should have done their magic by now, and you should see an empty `<svg>` element in your page. You have to keep `npm start` running and a browser window pointing to `localhost:3000` for that.

Congratz! You just made your first React component with ES6 classes. Or at least the first in this book. You're awesome!

Here's what happens next:

1. We'll make `H1BGraph` load our dataset
2. Build a Histogram component
3. Add dynamic meta text descriptions
4. Add some data filtering