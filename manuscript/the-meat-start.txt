{#the-meat-start}
# Visualizing data with React and d3.js

Welcome to the main part of React+d3.js. I’m going to walk you through an example of building a visualization using React and d3.js.

We're going to build a subset of the code I used to [visualize the salary distribution of H1B workers](http://swizec.github.io/h1b-software-salaries/#2014-ca-engineer) in the United States software industry.

![H1B salary distribution for engineers in California](images/engineers-california.png)

If you skipped the [environment setup section](#the-environment), make sure you’ve installed the following dependencies:

* d3.js
* React
* Lodash
* autobind-decorator

You should also have some way of running a static file server. I like having a simple node.js server that enables hot loading via Webpack.

We’re going to put all our code in a `src/` directory, and serve the compiled version out of `static/`. A `public/data/` directory is going to hold our data.

Before we begin, you should copy the dataset from the stub project you got with the book. It should be in the `public/data/` directory of your project.

## JSX

We’re going to write our code in JSX, a JavaScript syntax extension that lets us treat XML-like data as normal code. You can use React without JSX, but I feel that it makes React’s full power easier to use.

The gist of JSX is that we can use any XML-like string just like it is part of JavaScript. No Mustache or messy string concatenation necessary. Your functions can return straight-up HTML, SVG, or XML.

For instance, the code that renders our whole application is going to look like this:

{crop-start-line=399,crop-end-line=402,linenos=off,lang=jsx}
<<[A basic Render](code_samples/old/main.jsx)

Which compiles to:

{title="JSX compile result", linenos=off, lang=js}
    React.render(
        React.createElement(H1BGraph, {url: “data/h1bs.csv”}),
        document.querySelectorAll(‘.h1bgraph’)[0]
    );

As you can see, HTML code translates to `React.createElement` calls with attributes translated into a property dictionary. The beauty of this approach is two-pronged: you can use React components as if they were HTML tags and HTML attributes can be anything.

You’ll see that anything from a simple value to a function or an object works equally well.

I'm not sure yet whether this is better than separate template files in Mustache or whatever. There are benefits to both approaches. I mean, would you let a designer write the HTML inside your JavaScript files? I wouldn't, but it's definitely better than manually `+`-ing strings or Angular's approach of putting everything into HTML. Considerably better.

If you skipped the setup section and don't have a JSX compilation system set up, you should do that now. You can also use the project stub you got with the book.

## The basic approach

Because SVG is an XML format that fits into the DOM, we can assemble it with React. To draw a `100px` by `200px` rectangle inside a grouping element moved to `(50, 20)` we can do something like this:

{title="A simple rectangle in React",linenos=off,lang=jsx}
    render: function () {
        return (
            <g transform="translate(50, 20)">
                <rect width="100" height="200" />
            </g>
        );
    }

If the parent component puts this inside an `<svg>` element, the user will see a rectangle. At first glance, this looks cumbersome compared to traditional d3.js. But look closely:

{title="A simple rectangle in d3.js",linenos=off,lang=js}
    d3.select("svg")
      .append("g")
      .attr("transform", "translate(50, 20)")
      .append("rect")
      .attr("width", 100)
      .attr("height", 200);

The d3.js approach outputs SVG as if by magic and looks cleaner because it's pure JavaScript. But it’s a lot more typing and function calls for the same result.

Well, actually, the pure d3.js example is 10 characters shorter. But trust me, React is way cooler.

My point is that dealing with the DOM is not d3.js’s strong suit, especially once you're drawing a few thousand elements and your visualization slows down to a leisurely stroll… if you’re careful.

You always have to keep an eye on how many elements you're updating. React gives you all of that for free. Its primary purpose in life is knowing exactly which elements to update when some data changes.

We're going to follow this simple approach:

* React owns the DOM
* d3 calculates properties

This way we leverage both React and d3.js for their best functions and not much else.

{#the-architecture}
## The architecture

To make our lives easier, we're going to use a flow-down architecture where the entire application state is stored in one place. The architecture itself inspired by Flux, but the way we're structuring it uses less code and is easier to explain. The downside is that our version doesn't scale as well as Flux would.

If you don't know about Flux, don't worry; the explanations are self-contained. I only mention Flux to make your Googling easier and to give you an idea of how this approach compares.

![The basic architecture](images/architecture.jpg)

The idea is this:

* The Main Component is the repository of truth
* Child components react to user events
* They announce changes up the chain of parents via callbacks
* The Main Component updates its truth
* The real changes flow back down the chain to update UI

This might look roundabout, but I promise, it’s awesome. It's definitely better than worrying about parts of the UI going out of date with the rest of the app.

![Data flows down](images/architecture_data.jpg)

Having your components rely solely on their properties is like having functions that rely only on their arguments. This means that if given the same arguments, they *always* render the same output.

If you want to read about this in more detail, Google "isomorphic JavaScript". You could also search for "referential transparency" and "idempotent functions".

Either way, functional programming for HTML. Yay!

## The HTML skeleton

We’re building the whole interface with React, but we still need to begin with some HTML. It's going to take care of including files and giving our UI a container.

Make an index.html file that looks like this:

{linenos=off,lang=html}
<<[HTML skeleton](code_samples/index.html)

These 20 lines do everything we need. The `<head>` sets some meta properties that Bootstrap recommends and includes Bootstrap's stylesheet. This is a good approach for when you only need Bootstrap's default styles and don't want to change anything. We'll use `require()` statements to load our own stylesheets with Webpack.

The `<body>` tag creates a container and includes the JavaScript code. We didn’t really need a `<div>` inside a `<div>` like that, but I like to avoid taking over the whole `.container` with React. This gives you more flexibility for adding dumb static content.

At the bottom, we load our compiled JavaScript from `static/bundle.js`. This is a virtual path created by our dev server, so it doesn't point to any actual files.

## Structuring your React app

As you can guess from the earlier chapter about architecture, we're going to structure your app into components. Deciding what to put into one component and what into another is one of the hardest problems in engineering.

Whole books have been written about that so here's a rule of thumb that I like to use: If you have to use the word "and" to describe what your component does, then it should become two components.

Once you have those two components, you can either make them child components of a bigger component, or you can make them separate. This depends on their re-usability.

For instance, to build our H1B histogram visualization, we are going to build two top-level components:

 - H1BGraph, which handles the whole UI
 - Histogram, which is a passive component for rendering labeled histograms

Histogram is going to be a child of H1BGraph in the final hierarchy, but we might use it somewhere else. That makes it a good candidate for a stand-alone component.

Other components such as the mean value line, filter controls, and title/description meta components are very specific to this use-case, so we'll build them as child components of H1BGraph. We still want to build them as separate components, and not as top-level parts of H1BGraph, so that they are easier to reason about, reusable locally within H1BGraph, and easier to write tests for.

We're not going to write tests here, though. That's a topic for another book. Right now we want to focus on React and d3.js.

Each component will have its own folder inside `src/components/`, or its parent component, and at least an `index.jsx` file. Some will also have style definitions, child components, and other JavaScript files.

In theory, each component should be accessible with `require('./MyComponent')`, and rendered with `<MyComponent {...params} />`. If a parent component has to know details about the implementation of a child component, something is going wrong.

You can read more about these ideas, if you google for ["leaky abstractions"](https://en.wikipedia.org/wiki/Leaky_abstraction), ["single responsibility principle"](https://en.wikipedia.org/wiki/Single_responsibility_principle), ["separation of concerns"](https://en.wikipedia.org/wiki/Separation_of_concerns), and ["structured programming"](https://en.wikipedia.org/wiki/Structured_programming). Books from the late 90's and early 2000's when object oriented programming was The Future (tm) are the best source of [curated] info in my experience.

## Bootstrap your app into place

Let's start by bootstrapping our app into place. We're going to make a simple `src/index.jsx` file - that's the main entry file for our app, if you remember from the environment section - and an empty `H1BGraph` component that renders an SVG element.

We start by importing `React` and `H1BGraph`.

{crop-start-line=5,crop-end-line=8,linenos=off,lang=jsx}
<<[Import main dependencies](code_samples/es6/index.jsx)

We're using ES6 style imports instead of `require()` because it gives us greater flexibility to import just the parts we want and reads like a normal English sentence in most common use cases. You'll see this play out more in future examples.

Keep in mind that the second argument must be a string even if you're importing a library.

For the sake of convenience, we use this opportunity to define two helper functions on the `String` class: capitalize and decapitalize. We could use a full-blown string library for this sort of thing, but there's no need.

{crop-start-line=14,crop-end-line=25,linenos=off,lang=jsx}
<<[Define two string helpers](code_samples/es6/index.jsx)

Now we'll be able to capitalize and decapitalize any string in our codebase with a call like `"some thing".capitalize()`. We're going to use this in our `Title` and `Description` meta components, but we define it here because it changes the `String` object globally. Doing that deep down in a child component feels weird.

All we need now is to render `H1BGraph` into the page.

{crop-start-line=38,crop-end-line=47,linenos=off,lang=jsx}
<<[Render H1BGraph onto page](code_samples/es6/index.jsx)

This tells React to take control of the HTML element with the `h1bgraph` class and render the `H1BGraph` component. In our case that's a `<div>` inside the main container.

You can do this part in many ways. You could build it as a Backbone view, as a jQuery plugin, or even integrate with Angular. The approach we're using is the simplest when no other environment exists in your project.

If you've kept `npm start` running in the background, it should complain that `components/H1BGraph` doesn't exist. Let's fix that and get an empty `<svg>` element rendering.

## An empty component

All of our components are going to start the same way - some imports, a class with a `render()` method, and a default module export. That's the minimum we need in `<component>/index.jsx` to define a component that doesn't break our build.

Our main entry file already tries to render the `H1BGraph` component into the page so let's start with that. As we add more stuff later, this will become our main component.

{crop-start-line=5,crop-end-line=7,linenos=off,lang=jsx}
<<[Basic imports](code_samples/es6/H1BGraph/index.jsx)

First we import React, and a base `Component` class. We have to import `React` even if we don't use it explicitly because hot loading otherwise complains that React is not defined. We'll use the `Component` class to build our own components.

Then we import the `autobind` decorator. Decorators are a feature from the future and are becoming part of vanilla JavaScript with ES7. If you're familiar with Python, this is the same thing - decorators wrap functions in other functions.

The autobind decorator makes sure functions are always bound to current object scope, which is convenient when you want to pass them around as callbacks. It means you don't have to wrap them in a fat arrow function or bind them manually each time.

React's official documentation suggests binding all event callbacks in your object constructor, but I think `autobind` is a better approach.

{crop-start-line=12,crop-end-line=25,linenos=off,lang=jsx}
<<[Empty H1BGraph component](code_samples/es6/H1BGraph/index.jsx)

Then we define a component that renders an empty `<svg>` tag inside a `<div>`. A component must have at least a `render()` function, otherwise React throws an error when it tries to render.

We're using ES6's concept of classes and class inheritance to extend React's basic `Component`, which we imported earlier. This is widely accepted as more readable than JavaScript's old/standard prototypical inheritance.

In theory it's equivalent to using the old `React.createClass`, or something like the `Object.assign(Component, { // ... })` approach. A new class is built that merges properties and methods of the base class with the properties and methods of your class.

