# The environment

Before we begin, let’s set up a work environment. We’re after three things:

 * page should auto-refresh when we make changes
 * our code should auto-compile when we save a file
 * a good way to manage dependencies and modules

To achieve these, we’re going to use Grunt, Browserify, Bower, and Npm. This will make coding a joy, and ultimately enable us to host our visualization on anything capable of serving static files. Even the free Github Pages will be enough.

And let me tell you, there’s nothing like free static page hosting when 25,000 visitors descend upon your site in four hours.

If you already know how to set this all up. Great! Skip to next chapter.

## NPM for server-side tols

NPM is node.js’s default package manager. Originally used only for dependency management in node.js projects, it seems to have taken hold of the JavaScript world as a way to manage the proverbial tool belt.

We’ll use it to install the other tools we need.

Make sure you have it by installing node.js from [nodejs.org](http://nodejs.org). Grunt, Bower, and our development server will run in node as well.

Once you’ve got it, create a working directory, navigate to it, and run:

{linenos=off}
    npm init .

This will create a `package.json` file, which stores some basic info about your project. Most importantly, it’s got a list of dev dependencies. This is useful when you return to a project months or years later, and can’t remember how to get it running.

Also great, if you want to share the code.

## The development server

Production servers are beyond the scope of this book, but we need a server running locally. You could work on a static website without one, but we’re loading data into the visualisation dynamically and that makes browser security models panic.

We’re going to use `live-server`, which is a great static server written in JavaScript. Its biggest advantage is that the page refreshes automatically when CSS, HTML, or JavaScript files in the current directory change.

Just run:

{linenos=off}
    npm install -g live-server

If all went well, you should be able to start the server by running `live-server` in the command line. It’s even going to open a browser tab pointing at `http://localhost:8080` for you.

## Compiling our code

Strictly speaking, we’re writing JavaScript and some CSS. We don’t *really* have to compile our code. But it’s easier to work with, if we do.

Our compilation process is going to do three things:

* compile Less to CSS
* compile JSX to pure JavaScript
* concatenate source files

We have to compile Less because browsers don’t support it natively. We’re not going to use it for anything super fancy, but I prefer having some extra power in my stylesheets. Makes them easier to write.

You can use some other compile-to-CSS language, or even straight up CSS, but the code samples in this book assume you’re using Less.

Compiling JSX is far more important. 

JSX is React’s new file format that lets us embed HTML snippets straight in our JavaScript code. You’ll often see render methods doing something like this:

{crop-start-line=418,crop-end-line=422,linenos=off,lang=jsx}
<<[A basic Render](code/src/main.jsx)

See, we’re treating HTML - in this case an H1BGraph component - just like a normal part of our code. I haven’t decided yet if this is cleaner than something like Mustache yet, but it’s definitely much better than manually `+`-ing strings together.

As you’ll see later, it’s also very powerful.

But obviously, browsers don’t support this format, so we have to compile it into JavaScript. The above code ends up looking like this:

{title=“JSX compile result”, linenos=off, lang=js}
    React.render(
        React.createElement(H1BGraph, {url: “data/h1bs.csv”}),
        document.querySelectorAll(‘.h1bgraph’)[0]
    );

React gives us a `JSXTransform` that handles these transformations in the browser, but that wastes visitor’s CPU cycles and makes our site slower. It will even throw a warning in the console, telling you never to use it in production.

Finally, we concatenate all our code into a single file because that makes it quicker to download for users. Instead of starting a gazillion requests for each and every file, the client only ever makes one request.

### Install Grunt

We’re going to use [Grunt](http://gruntjs.com) for all of this. Grunt is a tool that lets us write glorified bash scripts in JavaScript. Its main benefits are a large community that creates plugins for every imaginable thing, and simple JavaScript based configuration.

To install Grunt and the plugins we need, run:

{linenos=off}
    npm install --saveDev grunt
    npm install --saveDev grunt-browserify
    npm install --saveDev grunt-contrib-less
    npm install --saveDev grunt-contrib-watch
    npm install --saveDev jit-grunt
    npm install --saveDev reactify

[Browserify](http://browserify.org) will allow us to write our code in modules that we can use with `require(‘foo.js’)`. Just like we would in node.js. It’s also going to concatenate the resulting module hierarchy into a single file.

[Reactify](https://github.com/andreypopp/reactify) will take care of making our JSX files work with Browserify.

[Less](https://github.com/gruntjs/grunt-contrib-less) will compile Less files to CSS, `watch` will automatically run our tasks when files change, and `jit-grunt` loads all these plugins for us, so we don’t have to specify them manually.

### Grunt Config

Now that’s installed, we need a `Gruntfile.js` for our config.

We’ll define three tasks:

* `less`, for compiling stylesheets
* `browserify`, to compile JSX files
* `watch`, to make sure Grunt keeps compiling in the background

The basic file with no configs should look like this:

{linenos=off,lang=js}
    module.exports = function (grunt) {
        require(‘jit-grunt’)(grunt);
        
        grunt.initConfig({ /* ... */ });
  
        grunt.registerTask(‘default’, 
                           [‘less’, ‘browserify:dev’, ‘watch’]);
    );

We add the three tasks inside `initConfig`:

{linenos=off,lang=js,crop-start-line=6,crop-end-line=17}
<<[Less task config](code/Gruntfile.js)

This sets a couple of options for the less compiler and tells it which file we’re interested in.

{linenos=off,lang=js,crop-start-line=19,crop-end-line=37}
<<[Browserify task config](code/Gruntfile.js)

We’re using the `reactify` transform to transform JSX files into plain JavaScript. The rest just tells `browserify` what our main file is going to be and where to put the compiled result.

I’m going to explain `debowerify` in the next section about client-side package management.

{linenos=off,lang=js,crop-start-line=39,crop-end-line=52}
<<[Watch task config](code/Gruntfile.js)

This tells `watch`, which files it needs to watch for changes, and what to do with them.

You should now be able to start compiling your code by running `grunt` in the command line. 

