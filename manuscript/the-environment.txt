{#the-environment}
# A good work environment

Before we begin, let’s set up a work environment. We’re after three things:

 * page should auto-refresh when we make changes
 * our code should auto-compile when we save a file
 * a good way to manage dependencies and modules

To achieve these, we’re going to use Grunt, Browserify, Bower, and Npm. This will make coding a joy, and ultimately enable us to host our visualization on anything capable of serving static files. Even the free Github Pages will be enough.

And let me tell you, there’s nothing like free static page hosting when 25,000 visitors descend upon your site in four hours.

If you already know how to set this all up. Great! Skip to next chapter.

## NPM for server-side tols

NPM is node.js’s default package manager. Originally used only for dependency management in node.js projects, it seems to have taken hold of the JavaScript world as a way to manage the proverbial tool belt.

We’ll use it to install the other tools we need.

Make sure you have it by installing node.js from [nodejs.org](http://nodejs.org). Grunt, Bower, and our development server will run in node as well.

Once you’ve got it, create a working directory, navigate to it, and run:

{linenos=off}
    npm init .

This will create a `package.json` file, which stores some basic info about your project. Most importantly, it’s got a list of dev dependencies. This is useful when you return to a project months or years later, and can’t remember how to get it running.

Also great, if you want to share the code.

## The development server

Production servers are beyond the scope of this book, but we need a server running locally. You could work on a static website without one, but we’re loading data into the visualisation dynamically and that makes browser security models panic.

We’re going to use `live-server`, which is a great static server written in JavaScript. Its biggest advantage is that the page refreshes automatically when CSS, HTML, or JavaScript files in the current directory change.

Just run:

{linenos=off}
    npm install -g live-server

If all went well, you should be able to start the server by running `live-server` in the command line. It’s even going to open a browser tab pointing at `http://localhost:8080` for you.

## Compiling our code

Strictly speaking, we’re writing JavaScript and some CSS. We don’t *really* have to compile our code. But it’s easier to work with, if we do.

Our compilation process is going to do three things:

* compile Less to CSS
* compile JSX to pure JavaScript
* concatenate source files

We have to compile Less because browsers don’t support it natively. We’re not going to use it for anything super fancy, but I prefer having some extra power in my stylesheets. Makes them easier to write.

You can use some other compile-to-CSS language, or even straight up CSS, but the code samples in this book assume you’re using Less.

Compiling JSX is far more important. 

JSX is React’s new file format that lets us embed HTML snippets straight in our JavaScript code. You’ll often see render methods doing something like this:

{crop-start-line=418,crop-end-line=422,linenos=off,lang=jsx}
<<[A basic Render](code/src/main.jsx)

See, we’re treating HTML - in this case an H1BGraph component - just like a normal part of our code. I haven’t decided yet if this is cleaner than something like Mustache yet, but it’s definitely much better than manually `+`-ing strings together.

As you’ll see later, it’s also very powerful.

But obviously, browsers don’t support this format, so we have to compile it into JavaScript. The above code ends up looking like this:

{title=“JSX compile result”, linenos=off, lang=js}
    React.render(
        React.createElement(H1BGraph, {url: “data/h1bs.csv”}),
        document.querySelectorAll(‘.h1bgraph’)[0]
    );

React gives us a `JSXTransform` that handles these transformations in the browser, but that wastes visitor’s CPU cycles and makes our site slower. It will even throw a warning in the console, telling you never to use it in production.

Finally, we concatenate all our code into a single file because that makes it quicker to download for users. Instead of starting a gazillion requests for each and every file, the client only ever makes one request.

### Install Grunt

We’re going to use [Grunt](http://gruntjs.com) for all of this. Grunt is a tool that lets us write glorified bash scripts in JavaScript. Its main benefits are a large community that creates plugins for every imaginable thing, and simple JavaScript based configuration.

To install Grunt and the plugins we need, run:

{linenos=off}
    npm install --save-dev grunt
    npm install --save-dev grunt-browserify
    npm install --save-dev grunt-contrib-less
    npm install --save-dev grunt-contrib-watch
    npm install --save-dev jit-grunt
    npm install --save-dev reactify

[Browserify](http://browserify.org) will allow us to write our code in modules that we can use with `require(‘foo.js’)`. Just like we would in node.js. It’s also going to concatenate the resulting module hierarchy into a single file.

[Reactify](https://github.com/andreypopp/reactify) will take care of making our JSX files work with Browserify.

[Less](https://github.com/gruntjs/grunt-contrib-less) will compile Less files to CSS, `watch` will automatically run our tasks when files change, and `jit-grunt` loads all these plugins for us, so we don’t have to specify them manually.

### Grunt Config

Now that’s installed, we need a `Gruntfile.js` for our config.

We’ll define three tasks:

* `less`, for compiling stylesheets
* `browserify`, to compile JSX files
* `watch`, to make sure Grunt keeps compiling in the background

The basic file with no configs should look like this:

{linenos=off,lang=js}
    module.exports = function (grunt) {
        require(‘jit-grunt’)(grunt);
        
        grunt.initConfig({ /* ... */ });
  
        grunt.registerTask(‘default’, 
                           [‘less’, ‘browserify:dev’, ‘watch’]);
    );

We add the three tasks inside `initConfig`:

{linenos=off,lang=js,crop-start-line=6,crop-end-line=17}
<<[Less task config](code/Gruntfile.js)

This sets a couple of options for the less compiler and tells it which file we’re interested in.

{id=browserify-config,linenos=off,lang=js,crop-start-line=19,crop-end-line=37}
<<[Browserify task config](code/Gruntfile.js)

We’re using the `reactify` transform to transform JSX files into plain JavaScript. The rest just tells `browserify` what our main file is going to be and where to put the compiled result.

I’m going to explain `debowerify` in the next section about client-side package management.

{linenos=off,lang=js,crop-start-line=39,crop-end-line=52}
<<[Watch task config](code/Gruntfile.js)

This tells `watch`, which files it needs to watch for changes, and what to do with them.

You should now be able to start compiling your code by running `grunt` in the command line. 

## Managing client-side dependencies with Bower

Client-side dependency management is the final piece in the puzzle.

Traditionally this is done by dumping all JavaScript plugins into a `vendor/` directory of some kind. Or having a `plugins.js` file and manually copy-pasting plugins in there.

The approach works fine right until the day you want to update one of the plugins. Then you can’t remember exactly which of the ten plugins with a similar name and purpose you used, or you can no longer find the Github repository and so on.

Even worse if the plugin’s got some dependencies that also need to be updated …

This is where Bower comes in. Instead of worrying about any of that, you can just run:

{linenos=off}
    bower install <something>

You could use `npm` for this, of course, but Bower can play with any source anywhere. It understands several package repositories, and can even download code straight from Github if need be.

To begin using it, init the project:

{linenos=off}
    bower init

This will create a `bower.json` file with some basic configuration.

When that’s done, install the four dependencies we need:

{linenos=off}
    bower install -S d3
    bower install -S react
    bower install -S bootstrap
    bower install -S lodash

We’re going to heavily rely on d3 and React. Bootstrap is there to give us some basic styling, and lodash will make it easier to  play around with the data.

All of these were installed in the `bower_components/` directory.

Which is awesome, but creates a small problem. If you want to use Browserify to include d3, you have to write something like `require(‘../bower_components/d3/d3.js’);`, which not only looks ugly, but also means you have to understand the internal structure of all the packages.

Using `debowerify` solves this.

Install it with:

{linenos=off}
    npm install —save-dev debowerify

And [we already configured Browserify](#browserify-config) to use it earlier. Now we’ll be able to use d3 with just `require(‘d3’);`. Much better.

## Final check

Congratulations! You should have a sane work environment now.

Running `grunt` will compile your code and keep it compiling. And `live-server` will start a static file server that auto-updates every time some code changes.

Check that your work directory has at least these files:

* package.json
* Gruntfile.js
* bower.json
* node_modules/
* bower_components/

I’d also suggest adding a `.gitignore` that looks like this:

{linenos=off}
<<[.gitignore](code/.gitignore)

And you might want to set up your text editor to understand JSX files.

If anything is acting up, Google and the respective project’s documentation are your friends. You can also try poking me on Twitter (@swizec).